_思考：线程执行为什么不能直接调用run()方法,而要调用start()方法？

>**多线程：一个程序方法中同时运行时分出多个分支来执行不同线程（一个程序有多个不同的执行路径同时运行）。**

- 因为调用start方法只是简简单单调用Thread接口中的start重写方法，最终也就是一条执行路径（方法调用，只有一条执行路径）。
- 在调用run方法的A方法中是和重写的start方法交替执行（不同的线程同时运行）。

![](https://cdn.nlark.com/yuque/0/2023/png/744990/1701482926662-3d286886-0e91-42e1-8afb-1275fd7ce01d.png)

## 三种创建线程方法

1. **继承Thread方法**

new MyThread().start()

1. **实现Runnable方法**

new Thread(new MyRunnable()).start();

或者

MyRunnable myThread = new MyRunnable();

Thread thread = new Thread(myThread, "xxxx线程");

Thread thread2 = new Thread(myThread, "yyyy线程");

thread.start();

thread2.start();

这种方式 Runnable的代码可被多个线程共享，适用于多个线程处理同一资源

1. **通过线程池(****其原理也是实现Runnable和继承Thread****)**

ExecutorService executorService = Executor.newCachedThreadPool

executorService.execute(new Runnable())

**阻塞状态：** sleep（）方法可进入阻塞，时间结束进入就绪状态 **守护线程：** 线程对象.setDaemon(true)必须在start（）方法之前调用 在守护线程中产生的新线程也是守护线程 不是所有任务都可以分配给守护线程，比如读写操作、计算逻辑 其他线程结束执行后，守护线程会立即结束 用jstack生成线程快照，来查看哪些是守护线程在jdk下的bin目录里 jstack -l pid（如9400） 含有daemon的是守护线程 tid、nid：cpu占有率

![](https://cdn.nlark.com/yuque/0/2023/png/744990/1701482926753-73f14813-a85a-4f45-999f-f68f6c8ef4ee.png)

## 进程，线程，协程/纤程

00_00_程序，进程，线程，纤程（协程）之间区别

进程：一个程序放在硬盘中运行起来的时候叫进程

线程：一个进程的最小单元叫线程，启动线程的两种方式，一种为方法(重写的run方法)的调用另一种为调用start方法（通俗说一个程序不同执行路径就叫多线程），实现的是多个线程并发执行的技术。

## sleep、join、yield

CPU是没有线程的概念，而是死循环地从内存中拿取一个个指令执行，单CPU的情况下执行某个线程一会儿后又执行另个线程一会儿

sleep：当前线程T1在睡眠时间内其他线程运行，**等睡眠到规定时间后T1**自动复活。

join：在运行当前线程T1时join其他线程T2，等调用的线程T2**运行完了**自己线程T1再去执行（等待另一个线程执行完，**顺序执行**）。

yield(很少用到)：当前线程正在执行的时候**停止进入等待队列**，回到等待队列里在系统的调度算法里头还是依然有可能把你刚回去的这个线程拿回来继续执行(**让出一下CPU给等待队列中的线程抢夺并执行**)，也就是让此线程返回到就**绪状态**

## 六种执行状态

Java线程状态迁移图：FSM（有限状态机）

![](https://cdn.nlark.com/yuque/0/2023/png/744990/1701482927276-9231af73-28ae-4b1b-ad0e-82e115890861.png)

6个状态:

public enum State {

_NEW_,

_RUNNABLE_, // 其中有Readly表示线程在CPU中的等待队列并等待CPU调用运行,就绪状态;Running运行状态,线程调度器选中执行使之CPU调用运行着线程

_BLOCKED_, // 加了synchronized锁的代码块没获取到锁的情况下

_WAITING_, //Thread.sleep(time),o.wait(time),t.join(time),LockSupport.parkUntil(),LockSupport.parkNanos等当遇到都要catch出InterruptedException异常然后做对这个中断做处理,而不能调用方法Interrupt中断来暂停线程，有时可以当waiting状态很久了要停止可调用Interrupt然后catch异常。

_TIMED_WAITING_, // 过了**某个时间**自动从Ready状态到Running

_TERMINATED_; // 结束状态

}

CPU中有多个线程当在CPU调度过程中某个时间执行这个线程隔个时间挂起并执行另一个线程（**线程被挂起**）

- 在一个wait或者sleep很长时间的线程中怎么唤醒这个线程,可以调用interrupt并catch抛出InterruptException异常,就可以进行对sleep中断

![](https://cdn.nlark.com/yuque/0/2023/png/744990/1701482926632-edccccca-0cb5-4439-aa8f-99333505d2d7.png)

- 只有synchronized需要操作系统调度锁住的时候锁状态才为_BLOCKED状态_
- JUC的锁底层原理是CAS操作，锁状态是在忙等待状态_WAITING或者TIMED_WAITING_

## 线程的打断

1. **interrupt()** ：实例方法，**设置线程中断标志**（打扰一下，你该处理一下中断）打断某个线程（**设置标志位**）
2. **isInterrupted()**：实例方法，有没有人打扰我？查询某线程是否被打断过（**查询标志位**）
3. **static interrupted()**：静态方法，有没有人打扰我（当前线程）？**复位**！查询当前线程是否被打断过，并重置打断标志（**查询标志位并复位**）

在遇到sleep、wait、join的时候，遇到执行interrupt打断操作设置标志位会在当前线程抛出异常**InterruptedException**。catch抛出异常时里面可以自定义怎么操作，JDK会默认把中断标识设置为false

- 当查看是否被设置中断位，如果有的话就在此线程**for(;;)**末尾加上break;
- 当遇到sleep\wait\join时中断线程,可以在其抛出异常catch时做出响应的操作
- interrupt()不能打断正在竞争锁的线程synchronized()和JUC中ReentrantLock锁的lock.lock()状态，但是在使用lock.lockInterruptibly();时，interrupt可以被打断其线程

### 优雅结束线程

1. 使用stop（终止），suspend（暂停），resume（恢复）可以粗暴结束线程和恢复线程（释放出所有的锁并不会做善后工作），会导致**数据不一致**问题，所以被废弃掉
2. volatile标志（只要**不依赖while循环里面的中间状态**就行，比如if else条件来判断是否结束线程，上传文件中终止上次时之前少传数据和多传数据是没关系的）

1. 不适合某些场景（比如还没有同步的时候，线程做了wait receive accept等阻塞操作，没有办法循环回去）
2. 打断时间也不是特别精确，比如一个阻塞容器，容量为5的时候结束生产者，但是，由于volatile同步线程标志位的时间控制不是很精确，有可能生产者还继续生产一段儿时间

3. interrupt() and isInterrupted（比较优雅）：不适用与要依赖中间状态的逻辑
4. 精确控制在某个点上或者循环多少次或者某个值到哪个位置之后停止线程：业务线程和外面要结束的线程通过**锁形式**配合使用来决定是否停止线程