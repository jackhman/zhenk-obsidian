## 重复消息
重复消息产生的原因主要涉及网络分区、消息重试、生产者端的确认机制以及消费者的处理逻辑等多个方面。以下是一些可能导致重复消息的原因及相应的解决方法：

1. **网络分区：**
   - **原因：** 网络分区可能导致消息在传输过程中的不确定性，使得消息可能被多次发送。
   - **解决方法：** 提高网络的稳定性，采用可靠的网络通信方式，如使用可靠性较高的网络协议，例如 TCP。
2. **消息重试：**
   - **原因：** 生产者在发送消息时，由于网络波动、Broker 故障等原因可能触发消息的重试机制，导致消息被重复发送。
   - **解决方法：** 生产者需要实现幂等性，确保同一条消息的重复发送不会对系统产生不一致的影响。此外，可以通过消息的唯一标识（Message ID）判断消息是否已经发送过，避免重复发送。
3. **生产者端的确认机制：**
   - **原因：** 生产者在发送消息后，由于网络等原因未能及时收到 Broker 的 ACK 确认，触发生产者的消息重试机制。
   - **解决方法：** 提高网络的稳定性，优化消息发送的超时设置，确保生产者可以及时接收到 ACK 确认。另外，使用异步发送消息的方式，通过回调机制获取发送结果，避免同步发送的阻塞。
4. **消费者的处理逻辑问题：**
   
   - **原因：** 消费者在处理消息时，由于业务逻辑的问题，可能导致消息的处理不具备幂等性，从而产生不一致性。
   - **解决方法：** 消费者的业务逻辑需要具备幂等性，即同一条消息的重复消费不会导致业务逻辑上的错误。在处理消息时，可以使用一些幂等性的技术手段，例如幂等性检查、唯一标识的去重等。
5. **消息消费确认失败：**
   - **原因：** 消费者在处理消息后未能及时向 RocketMQ 发送确认信息（ACK），导致消息被重新推送。
   - **解决方法：** 消费者在处理消息后需要及时发送确认信息，确保消息被成功处理。可以选择同步 ACK 或异步 ACK，确保消费者的 ACK 机制正常运作。

在设计和实现系统时，需要综合考虑以上因素，并采取相应的措施来降低重复消息的产生和影响。这包括提高网络可靠性、实现消息的幂等性、优化生产者和消费者的配置等。

### 处理方式
重复消息产生的原因主要涉及网络分区、消息重试、生产者端的确认机制以及消费者的处理逻辑等多个方面。以下是一些可能导致重复消息的原因及相应的解决方法：

1. **网络分区：**
   - **原因：** 网络分区可能导致消息在传输过程中的不确定性，使得消息可能被多次发送。
   - **解决方法：** 提高网络的稳定性，采用可靠的网络通信方式，如使用可靠性较高的网络协议，例如 TCP。
2. **消息重试：**
   - **原因：** 生产者在发送消息时，由于网络波动、Broker 故障等原因可能触发消息的重试机制，导致消息被重复发送。
   - **解决方法：** 生产者需要实现幂等性，确保同一条消息的重复发送不会对系统产生不一致的影响。此外，可以通过消息的唯一标识（Message ID）判断消息是否已经发送过，避免重复发送。
3. **生产者端的确认机制：**
   - **原因：** 生产者在发送消息后，由于网络等原因未能及时收到 Broker 的 ACK 确认，触发生产者的消息重试机制。
   - **解决方法：** 提高网络的稳定性，优化消息发送的超时设置，确保生产者可以及时接收到 ACK 确认。另外，使用异步发送消息的方式，通过回调机制获取发送结果，避免同步发送的阻塞。
4. **消费者的处理逻辑问题：**
   - **原因：** 消费者在处理消息时，由于业务逻辑的问题，可能导致消息的处理不具备幂等性，从而产生不一致性。
   - **解决方法：** 消费者的业务逻辑需要具备幂等性，即同一条消息的重复消费不会导致业务逻辑上的错误。在处理消息时，可以使用一些幂等性的技术手段，例如幂等性检查、唯一标识的去重等。
5. **消息消费确认失败：**
   - **原因：** 消费者在处理消息后未能及时向 RocketMQ 发送确认信息（ACK），导致消息被重新推送。
   - **解决方法：** 消费者在处理消息后需要及时发送确认信息，确保消息被成功处理。可以选择同步 ACK 或异步 ACK，确保消费者的 ACK 机制正常运作。

在设计和实现系统时，需要综合考虑以上因素，并采取相应的措施来降低重复消息的产生和影响。这包括提高网络可靠性、实现消息的幂等性、优化生产者和消费者的配置等。


## 消息积压
![[image-20240120100325437.png]]

在顺序消费消息的场景中，消息落后量（积压量）在上午8点后慢慢增加，最终在饭点达到了报警阈值…

### 为什么消息会积压？
当然是消费消息的速度赶不上消息生产的速度了啊，这里面又包含了三层信息，生产者太快、消费者太慢、生产者即太快消费者又太慢。于是乎开启“胡思乱想”模式得到了以下三个猜想

**猜想一**： 频繁的数据改动导致生产者短时间内生产消息过多，消费者来不及消费

**猜想二**： 生产者正常，但消费者消费消息出了点问题，导致消费过慢。如消费线程夯住，或者消费逻辑抛异常了，导致消费线程卡住，或逻辑不断的重试。新的消息需要继续消费，老的消息还要不断重试，消费者表示它比较累，它鸭梨山大，它觉得就像我们这届年轻人一样，承担了过多……

**猜想三**： 约等于猜想一加猜想二同时存在

问题发生后，需要先了解下这个生产者和消费者的相关信息

生产者是商品价格、状态等信息发生变更时即发MQ

消费者是统计商品的最大价格和最小价格等数据，因此需要顺序消费消息

简单聊聊顺序消息啊，顺序消息，即先发的消息先消费，后发的消息后消费，因此这里可以拆成三个维度的顺序性：

**消息发送的顺序性**
**消息存储的顺序性**
**消息消费的顺序性**
![[image-20240120100436385.png]]

RocketMq的顺序消息采用的方案是分区有序，即保证单个队列的消费是顺序的，举个例子：

张三的订单-3经历了创建订单，支付订单、订单发货三个流程，李四的订单-4也是如此，现在要对它们顺序消费（不然先收到订单发货的消息，过一段时间才收到订单创建的消息你懵不懵啊）
**1、从消息发送的角度来看**
RcoketMq要保证订单-3的消息是顺序的，订单4的消息是顺序的，而订单3和订单4之间并不要求有序，如下图，RocketMq采用的方案是将订单3的消息都放在了队列1，订单4的消息都放在了队列2
![[image-20240120100512216.png]]

**2、从消息存储的角度来看**
RocketMq采用了队列文件来存储消息，即先进先出，这里不做过多说明

**3、 从消息消费的角度来看**
对于顺序消息，RocketMq采用单线程来消费一个队列的消息，在上图中只有两个队列的情况下，顺序消息消费的最大并发度就只有2了，如下图：
![[image-20240120100552435.png]]
