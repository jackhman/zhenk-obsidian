## RocketMQ存储设计

![](https://cdn.nlark.com/yuque/0/2021/png/744990/1621936206496-82856296-2aa5-4ea7-8f2f-1aebe04e27b0.png)

消费者分组、生产者分组，主流是以消费组作为业务的处理的

**在提高消息的并发度可以提高Queue的值。**

### Domain Model

#### Message

messageId在mq中的一个broker是全局的，messageKey是业务系统生成的，是业务系统生成的可以作为业务上面的唯一索引，在分布式事务中要确定幂等性的时候就使用到此字符串，可以根据业务来解决消息重复。equals 和 hashCode 可以确定消息能幂等操作和确定消息一致性。

#### Topic

一类消息分类，subTopic 跟tags有关，是对消息进行整体分类，表示的是某一类消息

#### Queue

消息的物理单元，涉及到消费，涉及到消费进度，涉及处理中间还有多少消息堆积，消息处理的QPS，TPS，以及消息消费的Offset，把Queue存储在更多的主机上时

#### Offset

消费位点，对应的是Queue是一对一关系，所以相对Topic而言就是n对1关系。

#### Group

业务场景中，如果有一堆发送者，一堆消费者，所以这里使用Group的概念进行管理。

1. **顺序消费：**如果要顺序操作的话会出现只能是一个Topic对应一个Queue，而和并发度中1对n产生矛盾。但是在实际生产中不会对消息顺序消费产生严格要求所以可以使用1对n的Topic和Queue比例。
2. **消息重复：**在业务当中不能确定消息是否重复性，所以在开发业务代码的时候要根据幂等性来尽量杜绝消息的重复。在网络请求的系统中都会或多或少的出现重复现象。

**造成消息重复的根本原因是：网络不可达（网络波动）。所以如果消费者收到两条一样的消息，应该是怎么处理？**

RocketMQ 不保证消息不重复，如果你的业务要严格确保消息不重复，需要在自己的业务端进行去重。

1、 消费端处理消息的业务逻辑保持幂等性

2、 确保每一条消息都有唯一的编号且保证消息处理成功与去重表的日志同时出现

## RocketMQ消息存储结构

文本存储的好处是高可用，RabbitMQ存储的消息是放在内存中的没有相对应高可用

![](https://cdn.nlark.com/yuque/0/2021/png/744990/1621937981647-eebe712a-e922-4dcd-a659-900c5061c0da.png)

- **commitLog**：消息存储目录，消息真正的物理存储文件，每台Broker上的被本机器所有ConsumeQueue共享，存放了Consume Queues、Message Key、Tag等所有信息，可以在ConsumeQueue丢失的情况下仍能通过CommitLog完全恢复。在其文件夹目录下的每个文件都会有1G的大小因为这样可以由于mmap的缘由先占满然后好映射。是混合式存储的，对应的consumerqueue索引干掉了只要commitLog存在索引还是再次生成。半事务：只生成了commitLog还没有生成对应的索引对应目录，当完全事务的时候就才会生成索引。
- **config**：运行期间一些配置信息
- **consumerqueue**：消息消费队列存储目录(**只存偏移量信息**)，是消息的逻辑队列类似DB的索引文件存储的是指向物理存储的地址，每个Topic下的每个Message Queue都有一个在此目录下一个对应的ConsumeQueue文件
- **index**：消息索引文件存储目录
- **abort**：如果存在改文件则 Broker 非正常关闭
- **checkpoint**：文件检查点，存储 CommitLog 文件最后一次刷盘时间戳
- **consumerqueue** 最后一次刷盘时间，index 索引文件最后一次刷盘时间戳

生产的消息是顺序写入到commitLog中，**但是消费者消费是随机读**（源码中查看）的，利用PageCache机制可以批量从磁盘作为cache读取存到内存中加速后续的读取速度。

如果只生成一个commitLog 而没有生成Consumequeue的话这个事务为半事务。

## 零拷贝与MMAP

详细见：

此处为语雀内容卡片，点击链接查看：[https://www.yuque.com/muzihua/study/b7c462584622ea1cf2fd8890eb584549](https://www.yuque.com/muzihua/study/b7c462584622ea1cf2fd8890eb584549)

![](https://cdn.nlark.com/yuque/0/2021/png/744990/1621958683846-bacb7813-91ca-40e8-9b79-42004f72a0c1.png)

相对于Kafka为啥会很快是因为使用了零拷贝，里面进行通信的是fd，导致消息不能顺序读写

**sendfile**不需要走用户态，直接从内核态中发送文件描述符（表示的是在内核的一些东西），在用户态（顺序消息、消息过滤）中拿到这些是没有什么用处的，所以只能使用mmap

**fd**：当打开一个文件时，内核向进程返回一个文件描述符（ open 系统调用得到 ），后续 read、write 这个文件时，则只需要用这个**文件描述符**来标识该文件，将其作为参数传入 read、write ，是一个非负整数，本质上是文件的所在索引值。

**DMA**：石杉