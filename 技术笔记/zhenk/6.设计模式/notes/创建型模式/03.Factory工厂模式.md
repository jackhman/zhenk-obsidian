## 简介
* 任何可以产生对象的类或者方法，都可以称之为**工厂**
* 单例也是一种工厂，其中getInstance静态方法产生对象称之为**静态工厂**
* 定制生产过程的方式有很多种：**简单工厂**、**抽象工厂**、**工厂方法**、**静态简单工厂**（其中单例模式也是一种静态简单工厂）
* 产生对象的new过程（多态）弊端：在改变某种产品的时候需要在客户端中修改其new 对象，这时候可以把new对象过程由工厂来实现。

## 应用场景
* 任意定制交通工具：简单工厂，继承 Moveable
* 任意定制这个交通工具的生产过程：Moveable xx = XXFactory.create()

工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式，同时隐藏了创建细节。主要的工厂模式有三种：简单工厂模式、工厂方法模式和抽象工厂模式。

1. **简单工厂模式（Simple Factory Pattern）：**
    - **特点：**
        - 由一个工厂类根据传入的参数决定创建哪一种产品类的实例。
        - 客户端无需关心对象的创建过程，只需要知道产品的类型。
    - **缺点：**
        - 工厂类负责所有产品的创建，一旦需要添加新产品，就需要修改工厂类，不符合开闭原则。
2. **工厂方法模式（Factory Method Pattern）：**
    - **特点：**
        - 定义一个用于创建对象的接口，由子类决定实例化哪一个类。
        - 将实例化延迟到子类，符合开闭原则。
    - **缺点：**
        - 每增加一个产品，就需要增加一个工厂类，类的个数容易过多。
3. **抽象工厂模式（Abstract Factory Pattern）：**
    - **特点：**
        - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
        - 包含多个工厂方法，用于创建不同类型的产品族。
    - **缺点：**
        - 难以支持新种类的产品，因为要新增产品需要修改所有的工厂类。
4. **单例工厂模式：**
    - **特点：**
        - 通过工厂模式创建单例对象。
        - 确保在系统中只存在一个实例。
    - **缺点：**
        - 对于简单的单例模式，可能会显得过于繁琐。

**选择哪种工厂模式取决于项目的需求和复杂性。** 简单工厂适用于产品种类较少，且变化不频繁的情况。工厂方法适用于产品种类较多，但每个种类的产品创建逻辑相对简单的情况。抽象工厂适用于产品种类多，且产品之间存在较强关联性的情况。

## 抽象工厂
![[抽象工厂.png]]

> [!TIP] 介绍
> 一个工厂生产一个产品族(多个产品：固定产品)，产品一族上容易扩展，但是在产品上不能扩展，比如对固定产品所在一族的扩展，抽象方法；

提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类
![[image-20231204172031775.png]]

### 应用场景

* 程序需要处理不同系列的相关产品，但是您不希望它依赖于这些产品的具体类时，可以使用抽象工厂
* 好坏坦克一族，发射不同子弹和不同坦克形状
* 坦克一键风格替换

#### JDK源码中的应用

java.sql.Connection 
java.sql.Driver

### 优点

1. 可以确信你从工厂得到的产品彼此是兼容的。
2. 可以避免具体产品和客户端代码之间的紧密耦合。
3. 符合单一职责原则
4. 符合开闭原则

### 模式结构
![[抽象工厂模式结构.png]]


###  与其他模式的关系

- 在许多设计工作的初期都会使用[工厂方法模式](https://refactoringguru.cn/design-patterns/factory-method) （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)、 [原型模式](https://refactoringguru.cn/design-patterns/prototype)或[生成器模式](https://refactoringguru.cn/design-patterns/builder) （更灵活但更加复杂）。

- [生成器](https://refactoringguru.cn/design-patterns/builder)重点关注如何分步生成复杂对象。 [抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)专门用于生产一系列相关对象。 _抽象工厂_会马上返回产品， _生成器_则允许你在获取产品前执行一些额外构造步骤。

- [抽象工厂模式](https://refactoringguru.cn/design-patterns/abstract-factory)通常基于一组[工厂方法](https://refactoringguru.cn/design-patterns/factory-method)， 但你也可以使用[原型模式](https://refactoringguru.cn/design-patterns/prototype)来生成这些类的方法。

- 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)来代替[外观模式](https://refactoringguru.cn/design-patterns/facade)。

- 你可以将[抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)和[桥接模式](https://refactoringguru.cn/design-patterns/bridge)搭配使用。 如果由_桥接_定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， _抽象工厂_可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。

- [抽象工厂](https://refactoringguru.cn/design-patterns/abstract-factory)、 [生成器](https://refactoringguru.cn/design-patterns/builder)和[原型](https://refactoringguru.cn/design-patterns/prototype)都可以用[单例模式](https://refactoringguru.cn/design-patterns/singleton)来实现。

## 简单工厂
> [!TIP] 简单工厂介绍
> * 其可扩展性不好，每次新添加一种产品就要在此简单工厂类中创建一个方法来创建对象产品。
> * 简单工厂也就是定制生产过程的某种方式：简单，只创建交通工具的工厂


## 静态简单工厂
> [!TIP] 静态简单工厂介绍
> 单例模式也是一种工厂模式，叫静态工厂，getInstance方法表示的是获取对象。将对象的创建和对象本身业务处理分离

![[image-20231204172915574.png]]

### 应用场景
(1) 在JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间
```java
public final static DateFormat getDateInstance(); 
public final static DateFormat getDateInstance(int style); 
public final static DateFormat getDateInstance(int style,Locale locale);
```

(2) Java加密技术
```java
//获取不同加密算法的密钥生成器 
KeyGenerator keyGen=KeyGenerator.getInstance("DESede"); 
//创建密码器 
Cipher cp=Cipher.getInstance("DESede"); 
// 参考代码：DESEncrypt.java
```

### 简化场景

在有些情况下工厂类可以由抽象产品角色扮演，一个抽象产品类同时也是子类的工厂，也就是说把静态工厂方法写到抽象产品类中。
![[简单工厂模式的简化.png]]

## 工厂方法
> [!TIP] 工厂方法介绍
> 只生产一种产品（产品族中只有一个产品）的抽象工厂，在产品上容易扩展，比如新加某个产品，通过集成任意定制某一产品，并任意定制产品创建过程。

定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟到子类
![[image-20231204172643480.png]]

### 应用场景
1. 当你不知道改使用对象的确切类型的时候
2. 当你希望为库或框架提供扩展其内部组件的方法时

### 主要优点
1. 将具体产品和创建者解耦
2. 符合单一职责原则
3. 符合开闭原则

源码中的应用：

```java
// java api 
// 静态工厂方法 
Calendar.getInstance() java.text.NumberFormat.getInstance() java.util.ResourceBundle.getBundle() 
// 工厂方法 
java.net.URLStreamHandlerFactory 
javax.xml.bind.JAXBContext.createMarshaller
```

## 抽象工厂和工厂方法之间联系
只有一个产品的产品族（抽象工厂）就叫做工厂方法，也就是从某个抽象工厂继承，方便在产品上和产品上的产生过程的扩展
![[image-20231204172934160.png]]

**抽象工厂**：在产品族维度上容易扩展，但是在其产品族里面的产品不容易扩展（产品族里面的产品扩展的话需要在抽象工厂添加抽象方法并在具体工厂添加具体方法）
**Bean工厂**：

## 扩展知识
**抽象和接口（形容词用接口，名称用抽象类）**：抽象现实中实实在在存在的，比如食品是事实存在的但又不是一个具体的事物所以用抽象类。概念却又相对抽象些，不像面包那么确定。名称的概念用**抽象类**

可移动的东西明显是属于某个东西的属性，这时用接口比较合适，这个东西可能还是可吃的可玩的课多个接口。可以可以。。。用**接口**
