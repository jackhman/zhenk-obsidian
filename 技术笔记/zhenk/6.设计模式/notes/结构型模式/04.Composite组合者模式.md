> [!TIPS] 简介
> 亦称： 对象树、Object Tree、Composite、树状结构专用模式
> * 可以将对象组合成树状结构（目录和文件混合组成）， 并且能像使用独立对象一样使用它们。


## 结构
![[组合者模式结构图.png]]

## 组合模式优缺点
### 优点
-  你可以利用多态和递归机制更方便地使用复杂树结构。
-  _开闭原则_。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。

### 缺点
-  对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。

## 扩展知识
递归本就是一个压栈和弹栈过程
任何递归都可以改成栈式遍历

### 栈式遍历
栈式遍历（Stack-Based Traversal）通常指的是使用栈（stack）数据结构进行遍历操作，尤其是在树（Tree）或图（Graph）等数据结构中进行深度优先遍历（Depth-First Traversal）时使用的一种遍历方式。

在树的深度优先遍历中，栈的典型应用是通过迭代实现前序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）。以下是栈式遍历的基本思路：

#### 1.前序遍历
   - 将根节点压入栈。
   - 循环执行以下步骤，直到栈为空：
	   - 弹出栈顶节点并访问。
	   - 将右子节点压入栈（如果存在）。
	   - 将左子节点压入栈（如果存在）。
#### 2.中序遍历
- 初始化当前节点为根节点。
- 循环执行以下步骤，直到当前节点为空且栈为空：
	- 将当前节点及其所有左子节点压入栈，直至最左子节点。
	- 弹出栈顶节点并访问。
	- 将当前节点切换为右子节点。
#### 3.后序遍历
- 将根节点压入两次栈，其中一次标记为“访问标记”。
- 循环执行以下步骤，直到栈为空：
	- 弹出栈顶节点。
	- 如果是“访问标记”，则访问该节点；否则，将节点重新压入栈，并按右子节点、左子节点的顺序压入两次。
	- 根据访问标记的情况，决定是否将节点重新压入栈。

栈式遍历的优势在于它不使用递归，而是显式地使用栈数据结构进行遍历，适用于需要迭代实现的情况。这种方式可以避免递归深度过大导致的栈溢出问题，并且更容易控制遍历的过程。

#### 前中后遍历代码
```java
/**  
 * 二叉树非递归遍历---栈数据结构  
 *  
 * @author Jqh  
 * @date 2023/12/6  
 */
 public class BinaryTreeStackMain {  
    public static void main(String[] args) {  
        System.out.println("前序遍历结果：");  
        preOrderTraversal(TreeNode.buildTree());  
        System.out.println();  
        System.out.println("中序遍历结果：");  
        inOrderTraversal(TreeNode.buildTree());  
        System.out.println();  
        System.out.println("后序遍历结果：");  
        postOrderTraversal(TreeNode.buildTree());  
  
  
    }  
}  
  
/**  
 * 1. 二叉树节点定义  
 */  
class TreeNode {  
    int val;  
    TreeNode left;  
    TreeNode right;  
  
    public TreeNode(int val) {  
        this.val = val;  
    }  
      
    public static TreeNode buildTree() {  
        TreeNode root = new TreeNode(1);  
        root.left = new TreeNode(2);  
        root.right = new TreeNode(3);  
        root.left.left = new TreeNode(4);  
        root.left.right = new TreeNode(5);  
        return root;  
    }  
}
```

遍历详细算法
```java
import java.util.Stack;
public class BinaryTreeTraversal {  
  
    /**  
     * 前序遍历  
     */  
    public static void preOrderTraversal(TreeNode root) {  
        if (root == null) {  
            return;  
        }  
  
        Stack<TreeNode> stack = new Stack<>();  
        stack.push(root);  
  
        while (!stack.isEmpty()) {  
            TreeNode node = stack.pop();  
            System.out.print(node.val + " ");  
  
            if (node.right != null) {  
                stack.push(node.right);  
            }  
  
            if (node.left != null) {  
                stack.push(node.left);  
            }  
        }  
    }  
  
    /**  
     * 中序遍历  
     */  
    public static void inOrderTraversal(TreeNode root) {  
        if (root == null) {  
            return;  
        }  
        Stack<TreeNode> stack = new Stack<>();  
        TreeNode current = root;  
  
        while (current != null || !stack.isEmpty()) {  
            while (current != null) {  
                stack.push(current);  
                current = current.left;  
            }  
  
            current = stack.pop();  
            System.out.print(current.val + " ");  
            current = current.right;  
        }  
    }  
  
  
    /**  
     * 后序遍历  
     */  
    public static void postOrderTraversal(TreeNode root) {  
        if (root == null) {  
            return;  
        }  
  
        Stack<TreeNode> stack1 = new Stack<>();  
        Stack<TreeNode> stack2 = new Stack<>();  
        stack1.push(root);  
  
        while (!stack1.isEmpty()) {  
            TreeNode node = stack1.pop();  
            stack2.push(node);  
  
            if (node.left != null) {  
                stack1.push(node.left);  
            }  
  
            if (node.right != null) {  
                stack1.push(node.right);  
            }  
        }  
  
        while (!stack2.isEmpty()) {  
            System.out.print(stack2.pop().val + " ");  
        }  
    }  
  
}
```