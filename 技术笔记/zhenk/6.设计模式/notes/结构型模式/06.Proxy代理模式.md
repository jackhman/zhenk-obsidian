## 静态代理
* 代理类和被代理类(目标类)都是要统一现实某个接口，然后通过调用相同的方法来调用目标对象的模式。
* 因为在代理类中通过实现统一接口时可以代理被代理对象中的某些方法时，然后再加上代理类中自己的逻辑方法，不同代理类必须实现同一个接口因为那样的话就可以相互之间嵌套对方。有点类似装饰者模式
* 代理对象里面如果需要灵活指定被代理对象的话，需要代理对象和被代理对象都实现某个接口，然后把接口聚合到代理对象中并把实现的方法中调用接口方法

```java
public class ProxyMain implements Movable {  
    @Override  
    public void run() {  
        System.out.println("ProxyMain === run");  
    }  
  
    public static void main(String[] args) {  
        new TimeProxy(new LogProxy(new ProxyMain())).  
                run();  
    }  
}  
  
class TimeProxy implements Movable {  
  
    Movable m;  
  
    public TimeProxy(Movable m) {  
        this.m = m;  
    }  
  
    @Override  
    public void run() {  
        final long start = System.currentTimeMillis();  
        m.run();  
        final long end = System.currentTimeMillis();  
        System.out.println("time: " + (end - start));  
    }  
}  
  
class LogProxy implements Movable {  
    Movable m;  
  
    public LogProxy(Movable m) {  
        this.m = m;  
    }  
  
    @Override  
    public void run() {  
        System.out.println("start run ....");  
        m.run();  
        System.out.println("end run ....");  
    }  
}  
  
interface Movable {  
    void run();  
}
```

### 图解
new Proxy(new Tank()).move()，所以代理类需要添加参数为Movable接口的有参构造函数，这时候只能代理那些同时实现Movable的被代理类
![[静态代理的UML图.png]]


## 动态代理
* 如果想让LogProxy可以重用，不仅可以代理Tank，还可以代理任何其他可以代理的类型 Object  
* （毕竟日志记录，时间计算是很多方法都需要的东西），这时该怎么做呢？  全能代理，根据被代理类生产对应方法的代理类
* 分离代理行为与被代理对象  —— > 使用jdk的动态代理（reflection 通过二进制字节码分析类的属性和方法）
* 没有确定的代理类对象，而是根据Proxy.newProxyInstance()动态生成代理对象。
### JDK反射生成代理
#### JDK动态代理执行过程
jdk反射生成代理必须面向接口，这是由Proxy的内部实现决定的
通过反射观察生成的代理对象
![[JDK动态代理执行过程.png]]

```java
public class ReflectProxyMain {  
    public static void main(String[] args) {  
        final Tank tank = new Tank();  
        Movable m = (Movable) Proxy.newProxyInstance(Tank.class.getClassLoader(),  
                new Class[]{Movable.class},  
                new LogProxy(tank));  
        m.move();  
    }  
}  
  
interface Movable {  
    void move();  
}  
  
class Tank implements Movable {  
  
    @Override  
    public void move() {  
        System.out.println("Tank moving");  
    }  
}  
  
class LogProxy implements InvocationHandler {  
  
    Movable movable;  
  
    public LogProxy(Movable movable) {  
        this.movable = movable;  
    }  
  
    @Override  
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
        System.out.println("start  invoke");  
        Object o = method.invoke(movable, args);  
        System.out.println("end  invoke");  
        return o;  
    }  
}
```
#### 底层原理
##### [ASM](ASM.md)
可以直接操作编译后的二进制码然后load 到内存，是一个二进制字节码操作类库。可以动态代理final的被代理对象
#### 缺点
被代理类必须要实现某个接口

### Instrument
构造函数式拦截器，是 Java 提供的一个工具，用于在 Java 程序运行期间修改字节码。结合 Instrumentation，可以实现在类加载过程中对字节码进行修改，从而生成代理类。一般而言，生成代理的方式有两种：
1. **基于字节码生成代理：** 这是 Instrumentation 最常用的方式。通过在类加载过程中修改字节码，实现对原有类的增强，从而生成代理。
2. **动态代理：** 在 Java 中，动态代理是通过 Java 标准库提供的 `java.lang.reflect.Proxy` 实现的。这种方式不需要直接使用 Instrumentation，而是通过反射机制动态生成代理类。

以下是基于字节码生成代理的简单示例，使用 `Instrumentation` 的 `premain` 函数在类加载前进行字节码的修改：
```java
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.security.ProtectionDomain;

public class Agent {
    public static void premain(String agentArgs, Instrumentation inst) {
        inst.addTransformer(new MyClassTransformer());
    }

    static class MyClassTransformer implements ClassFileTransformer {
        @Override
        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                                ProtectionDomain protectionDomain, byte[] classfileBuffer) {
            // 在这里实现对字节码的修改
            // 这可以是手动修改字节码，也可以使用字节码操作库，比如 ASM 或 Javassist
            // 返回修改后的字节码数组
            return classfileBuffer;
        }
    }
}

```
上述代码中，`MyClassTransformer` 实现了 `ClassFileTransformer` 接口，通过在 `transform` 方法中修改字节码，实现对类的代理。在实际应用中，可以使用字节码操作库（如 ASM、Javassist）来简化字节码的生成和修改过程。

需要注意的是，基于字节码生成代理通常要处理较为底层的细节，使用动态代理可能更为方便。
### Cglib
#### 缺点
被代理类不能是final修饰

### Spring AOP
* @Aspect 需要往被代理类中切入的类
* @Before("execution (void com.mashibing.dp.spring.v2.Tank.move())") 表示在move方法执行之前切入方法
* @After("execution (void com.mashibing.dp.spring.v2.Tank.move())") 表示执行之后切入的方法
* 和IOC，Bean工厂，灵活装置 + 动态行为拼接（AOP）成就Spring
![[Spring AOP体系.png]]



## [与其他模式的关系](设计模式.md#代理模式与其他模式的关系)

## 扩展知识
动态语言：在运行的时候，可以直接改变类里面的属性和方法，反射只能找出类里面的属性和方法。