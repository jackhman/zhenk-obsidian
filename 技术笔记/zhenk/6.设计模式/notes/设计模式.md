# 行为型模式
> [!TIP] 行为型模式简介
> 行为模式负责对象间的高效沟通和职责委派。

## [策略模式](05.Strategy策略模式.md)
![策略模式](策略模式.png)

## [调停中介者模式](06.Mediator调停中介者模式.md)
![[调停中介者模式.png]]


# 结构型模式

## [装饰者模式](01.Decorator装饰者模式.md)

![[装饰者模式.png]]


## [桥接者模式](02.Bridge桥接者模式.md)
![[image-20231205164741036.png]]

# 各模式之间区别
## [Facade和Mediator之间区别](门面和调停者之间区别.md)

## [CoR和Observer之间区别](观察者和责任链之间区别.md)
* 可以和责任链模式结合使用，观察者模式就是多态的使用，观察某个行为的接口衍生出不同的动作。
* 在观察者模式中的观察者可能是责任链的处理器，当主题状态变化时，观察者将请求传递给责任链的头部。
## [Bridge和Decorator之间区别](桥接和装饰者之间区别.md)

# 模式总结表格

|                             图解                             |                   设计模式                    |                             简述                             |           一句话归纳           |          目的          |    生活案例    |
| :----------------------------------------------------------: | :-------------------------------------------: | :----------------------------------------------------------: | :----------------------------: | :--------------------: | :------------: |
| ![1701757598733](1701757598733.png) |          工厂模式（Factory Pattern）          |                    不同条件下创建不同实例                    |     产品标准化，生产更高效     |      封装创建细节      |    实体工厂    |
| ![1701757541716](1701757541716.png) |          抽象工厂（Factory Pattern）          |           提供一个创建一组相关或相互依赖对象的接口           |     产品标准化，生产更高效     |      封装创建细节      |    实体工厂    |
| ![1701757614399](1701757614399.png) |         单例模式（Singleton Pattern）         |        保证一个类仅有一个实例，并且提供一个全局访问点        |         世上只有一个我         |      保证独一无二      |      CEO       |
| ![1701757655273](1701757655273.png) |         原型模式（Prototype Pattern）         |                   通过拷贝原型创建新的对象                   |     拔一根猴毛，吹出千万个     |      高效创建对象      |      克隆      |
| ![1701757675093](1701757675093.png) |         建造者模式（Builder Pattern）         |                    用来创建复杂的复合对象                    | 高配中配和低配，想选哪配就哪配 |    开放个性配置步骤    |      选配      |
| ![1701757741231](1701757741231.png) |           代理模式（Proxy Pattern）           |         为其他对象提供一种代理以控制对这个对象的访问         | 没有资源没时间，得找别人来帮忙 |        增强职责        |      媒婆      |
| ![1701757751037](1701757751037.png) |          外观模式（Facade Pattern）           |             对外提供一个统一的接口用来访问子系统             |     打开一扇门，通向全世界     |      统一访问入口      |     slf4j      |
| ![1701757763887](1701757763887.png) |        装饰器模式（Decorator Pattern）        |                       为对象添加新功能                       |      他大舅他二舅都是他舅      |   灵活扩展、同宗同源   | JAVA IO ,奶茶  |
| ![1701757775651](1701757775651.png) |         享元模式（Flyweight Pattern）         |                使用对象池来减少重复对象的创建                |   优化资源配置，减少重复浪费   |       共享资源池       |  数据库连接池  |
| ![1701757787136](1701757787136.png) |         组合模式（Composite Pattern）         | 将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理 | 人在一起叫团伙，心在一起叫团队 |     统一整体和个体     |   组织架构树   |
| ![1701757796122](1701757796122.png) |         适配器模式（Adapter Pattern）         |                将原来不兼容的两个类融合在一起                |           万能充电器           |        兼容转换        |    电源适配    |
| ![1701757805486](1701757805486.png) |          桥接模式（Bridge Pattern）           |               将两个能够独立变化的部分分离开来               |          约定优于配置          |      不允许用继承      |       桥       |
| ![1701757827844](1701757827844.png) |         模板模式（Template Pattern）          |          定义一套流程模板，根据需要实现模板中的操作          | 流程全部标准化，需要微调请覆盖 |        逻辑复用        | 把大象装进冰箱 |
| ![1701757840931](1701757840931.png) |         策略模式（Strategy Pattern）          |              封装不同的算法，算法之间能互相替换              | 条条大道通罗马，具体哪条你来定 |    把选择权交给用户    |  选择支付方式  |
| ![1701757851984](1701757851984.png) | 责任链模式（Chain of Responsibility Pattern） | 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 |  各人自扫门前雪，莫管他们上霜  |      解耦处理逻辑      |     踢皮球     |
| ![1701757865048](1701757865048.png) |         迭代器模式（Iterator Pattern          |         提供一种方法顺序访问一个聚合对象中的各个元素         | 流水线上坐一天，每个包裹扫一遍 |  统一对集合的访问方式  |  逐个检票进站  |
| ![1701757875587](1701757875587.png) |          命令模式（Command Pattern）          |         将请求封装成命令，并记录下来，能够撤销与重做         |   运筹帷幄之中，决胜千里之外   |     解耦请求和处理     |     遥控器     |
| ![1701757885486](1701757885486.png) |           状态模式（State Pattern）           |                 根据不同的状态做出不同的行为                 |   状态驱动行为，行为决定状态   |     绑定状态和行为     |  订单状态跟踪  |
| ![1701757896180](1701757896180.png) |         备忘录模式（Memento Pattern）         |               保存对象的状态，在需要时进行恢复               | 失足不成千古恨，想重来时就重来 |     备份、后悔机制     |     草稿箱     |
| ![1701757907358](1701757907358.png) |        中介者模式（Mediator Pattern）         | 将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 | 联系方式我给你，怎么搞定我不管 |    统一管理网状资源    |     朋友圈     |
| ![1701758596666](1701758596666.png) |       解释器模式（Interpreter Pattern）       | 给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 | 我想说”方言“，一切解释权都归我 |    实现特定语法解析    |    摩斯密码    |
| ![1701757950712](1701757950712.png) |        观察者模式（Observer Pattern）         |            状态发生改变时通知观察者，一对多的关系            |          到点就通知我          |  解耦观察者与被观察者  |      闹钟      |
| ![1701757941260](1701757941260.png) |         访问者模式（Visitor Pattern）         |                稳定数据结构，定义新的操作行为                | 横看成岭侧成峰，远近高低各不同 | 解耦数据结构和数据操作 |    KPI考核     |


# 观察者模式与其他模式的关系
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)、 [命令模式](https://refactoringguru.cn/design-patterns/command)、 [中介者模式](https://refactoringguru.cn/design-patterns/mediator)和[观察者模式](https://refactoringguru.cn/design-patterns/observer)用于处理请求发送者和接收者之间的不同连接方式：

   - **责任链**按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
   - **命令**在发送者和请求者之间建立单向连接。
   - **中介者**清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
   - **观察者**允许接收者动态地订阅或取消接收请求。
- [中介者](https://refactoringguru.cn/design-patterns/mediator)和[观察者](https://refactoringguru.cn/design-patterns/observer)之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
   
   **中介者**的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 **观察者**的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。
   
   有一种流行的中介者模式实现方式依赖于**观察者**。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当**中介者**以这种方式实现时， 它可能看上去与**观察者**非常相似。
   
   当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和**观察者**并不相同， 但这仍是一种中介者模式。
   
   假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。

# 组合模式与其他模式的关系

- [桥接模式](https://refactoringguru.cn/design-patterns/bridge)、 [状态模式](https://refactoringguru.cn/design-patterns/state)和[策略模式](https://refactoringguru.cn/design-patterns/strategy) （在某种程度上包括[适配器模式](https://refactoringguru.cn/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](https://refactoringguru.cn/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。 
- 你可以在创建复杂[组合](https://refactoringguru.cn/design-patterns/composite)树时使用[生成器模式](https://refactoringguru.cn/design-patterns/builder)， 因为这可使其构造步骤以递归的方式运行。 
- [责任链模式](https://refactoringguru.cn/design-patterns/chain-of-responsibility)通常和[组合模式](https://refactoringguru.cn/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。
- 你可以使用[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历[组合](https://refactoringguru.cn/design-patterns/composite)树。
- 你可以使用[访问者模式](https://refactoringguru.cn/design-patterns/visitor)对整个[组合](https://refactoringguru.cn/design-patterns/composite)树执行操作。    
- 你可以使用[享元模式](https://refactoringguru.cn/design-patterns/flyweight)实现[组合](https://refactoringguru.cn/design-patterns/composite)树的共享叶节点以节省内存。 
- [组合](https://refactoringguru.cn/design-patterns/composite)和[装饰模式](https://refactoringguru.cn/design-patterns/decorator)的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
   
   **装饰**类似于**组合**， 但其只有一个子组件。 此外还有一个明显不同： **装饰**为被封装对象添加了额外的职责，**组合**仅对其子节点的结果进行了 “求和”。
   
   但是， 模式也可以相互合作： 你可以使用**装饰**来扩展**组合**树中特定对象的行为。
   
- 大量使用[组合](https://refactoringguru.cn/design-patterns/composite)和[装饰](https://refactoringguru.cn/design-patterns/decorator)的设计通常可从对于[原型模式](https://refactoringguru.cn/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

# 享元模式与其他模式的关系
- 你可以使用[享元模式](https://refactoringguru.cn/design-patterns/flyweight)实现[组合模式](https://refactoringguru.cn/design-patterns/composite)树的共享叶节点以节省内存。
- [享元](https://refactoringguru.cn/design-patterns/flyweight)展示了如何生成大量的小型对象， [外观模式](https://refactoringguru.cn/design-patterns/facade)则展示了如何用一个对象来代表整个子系统。
- 如果你能将对象的所有共享状态简化为一个享元对象， 那么[享元](https://refactoringguru.cn/design-patterns/flyweight)就和[单例模式](https://refactoringguru.cn/design-patterns/singleton)类似了。 但这两个模式有两个根本性的不同。  
	1. 只会有一个单例实体， 但是_享元_类可以有多个实体， 各实体的内在状态也可以不同。
	2. _单例_对象可以是可变的。 享元对象是不可变的。

# 代理模式与其他模式的关系

- [适配器模式](https://refactoringguru.cn/design-patterns/adapter)能为被封装对象提供不同的接口， [代理模式](https://refactoringguru.cn/design-patterns/proxy)能为对象提供相同的接口， [装饰模式](https://refactoringguru.cn/design-patterns/decorator)则能为对象提供加强的接口。
    
- [外观模式](https://refactoringguru.cn/design-patterns/facade)与[代理](https://refactoringguru.cn/design-patterns/proxy)的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 _代理_与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与_外观_不同。
    
- [装饰](https://refactoringguru.cn/design-patterns/decorator)和[代理](https://refactoringguru.cn/design-patterns/proxy)有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于_代理_通常自行管理其服务对象的生命周期， 而_装饰_的生成则总是由客户端进行控制。

# 访问者与其他模式的关系

- 你可以将[访问者模式](https://refactoringguru.cn/design-patterns/visitor)视为[命令模式](https://refactoringguru.cn/design-patterns/command)的加强版本， 其对象可对不同类的多种对象执行操作。
    
- 你可以使用[访问者](https://refactoringguru.cn/design-patterns/visitor)对整个[组合模式](https://refactoringguru.cn/design-patterns/composite)树执行操作。
    
- 可以同时使用[访问者](https://refactoringguru.cn/design-patterns/visitor)和[迭代器模式](https://refactoringguru.cn/design-patterns/iterator)来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。

# 六大原则+加强原则
## 指导思想
### 1.可维护性Maintainability
修改功能，需要改动的地方越少，可维护性就越好
### 2.可复用性Reusability
代码可以被以后重复使用
写出自己总结的类库
### 3.可扩展性Extensibility / Scalability
添加功能无需修改原.来的代码
### 4.灵活性flexibility / mobility / adaptability
代码接口可以灵活使用

## 六大原则 + 加强原则

### 1、单一职责原则（SRP）

SRP：Single Responsibility Principle，一个类只负责一项职责
* Single Responsibility Principle
* 一个类别太大，别太累，负责单一的职责
* Person、PersonManager
* 高内聚，低耦合
### 2、开闭原则（OCP）
OCP：Open Closed Principle，扩展开发，修改关闭（热插拔），一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭（使用接口和抽象类实现）。在不修改原有代码的情况下，可以通过扩展来增加新的功能。
* 对扩展开放，对修改关闭
	* 尽量不修改原来代码的情况下进行扩展
* 抽象化，多态是开闭原则的关键
### 3、里氏替换原则（LSP）
LSP：Liskov Substitution Principle，所有引用基类的地方必须能透明地使用其子类的对象（使用父类的地方一定可以使用子类）

* 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

* 继承关系中父类能出现的地方子类都可以出现，替换后而不影响程序的正确性。
### 4、依赖倒置原则（DIP）
DIP：Dependency Inversion Principle，这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体（**面向接口编程**）。

高层模块不应该依赖于底层模块，两者都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
* 依赖倒置原则
	* 依赖抽象，而不是依赖具体
	* 面向抽象编程

### 5、接口隔离原则（ISP）
ISP：Interface Segregation Principle，这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件[架构](http://lib.csdn.net/base/architecture)出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

一个类对另一个类的依赖应该建立在最小的接口上

* Interface Segregation Principle
* 每一个接口应该承担独立的角色，不干不该自己干的事儿
	* Flyable Runnable 不该合二为一
	* 避免子类实现不需要实现的方法
	* 需要对客户提供接口的时候，只需要暴露最小的接口
### 6、迪米特法则（LOD）
LoD：Law of Demeter，最少知道原则

也就是说，一个对象应该对自己需要的对象和方法尽可能少的了解，只与直接的朋友通信。直接的朋友是指出现在成员变量、方法输入、输出参数中的类。这样可以降低对象之间的耦合度。
* Law of Demeter
* 尽量不要和陌生人说话
* 在迪米特法则中，对于一个对象，非陌生人包括以下几类：
	* 当前对象本身(this)；
	* 以参数形式传入到当前对象方法中的对象；
	* 当前对象的成员对象；
	* 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
	* 当前对象所创建的对象。
* 和其他类的耦合度变低

### 7、合成/聚合复用原则（CARP）

CARP：Composition/Aggregate Reuse Principle，原则是尽量使用合成/聚合的方式，而不是使用继承

### 总结
* OCP：总纲，对扩展开放，对修改关闭
* SRP：类的职责要单一
* LSP：子类可以透明替换父类
* DIP：面向接口编程
* ISP：接口的职责要单一
* LoD：降低耦合
* CARP：尽量使用合成/聚合的方式，而不是使用继承

[Java与设计模式.pdf](https://refactoringguru.cn/design-patterns)

|   |   |
|---|---|
|第一部份、UML和模式介绍||
|com.javapatterns.uml|统一建模语言UML介绍|
|第二部份、面向对象的设计原则||
|com.javapatterns.openclose|“开-闭”原则|
|com.javapatterns.interfaces|专题：Java接口|
|com.javapatterns.liskov|里氏代换原则|
|com.javapatterns.dip|依赖倒转原则|
|com.javapatterns.isp|接口隔离原则|
|com.javapatterns.carp|组合/聚合复用原则|
|com.javapatterns.lod|迪米特法则|
|第三部份、创建模式||
|com.javapatterns.simplefactory|简单工厂模式|
|com.javapatterns.factorymethod|工厂方法模式|
|com.javapatterns.abstractfactory|抽象工厂模式|
|com.javapatterns.singleton|单例模式|
|com.javapatterns.singleton.mxrecord|专题：单例模式与MX记录|
|com.javapatterns.multilingual|专题：多例模式与多语言支持|
|com.javapatterns.keygen|专题：序列键生成器与单例及多例模式|
|com.javapatterns.builder|建造者模式|
|com.javapatterns.prototype|原始模型模式|
|com.javapatterns.serializable|专题：JavaBean的“冷藏”和“解冻”|
|第四部份、结构模式||
|com.javapatterns.adapter|适配器模式|
|com.javapatterns.windowadapter|缺省适配模式|
|com.javapatterns.xmlproperties|专题：适配器模式与XMLProperties|
|com.javapatterns.composite|合成模式|
|com.javapatterns.decorator|装饰模式|
|com.javapatterns.javaio|专题：设计模式在Java I/O中的应用|
|com.javapatterns.proxy|代理模式|
|com.javapatterns.proxy.smartproxy|专题：智能引用代理|
|com.javapatterns.proxy.imageloader|专题：虚拟代理的例子|
|com.javapatterns.flyweight|享元模式|
|com.javapatterns.facade|门面模式|
|com.javapatterns.bridge|桥梁模式|
|第五部份、行为模式||
|com.javapatterns.command.swingundo|专题：Swing库中的命令撤销和恢复|
|com.javapatterns.immutable|不变模式|
|com.javapatterns.strategy|策略模式|
|com.javapatterns.templatemethod|模板方法模式|
|com.javapatterns.servlet|专题：Servlet技术中的模式|
|com.javapatterns.observer|观察者模式|
|com.javapatterns.observerawt|专题：观察者模式与AWT中的事件处理|
|com.javapatterns.observersax|专题：观察者模式与SAX2浏览器|
|com.javapatterns.observertimer|专题：观察者模式与Swing定时器|
|com.javapatterns.iterator|迭代子模式|
|com.javapatterns.chainofresp|责任链模式|
|com.javapatterns.chainofresp.scheduler|专题：定时器与击鼓传花|
|com.javapatterns.command|命令模式|
|com.javapatterns.memento|备忘录模式|
|com.javapatterns.state|状态模式|
|com.javapatterns.doubledispatch|专题：单分派与多分派|
|com.javapatterns.visitor|访问者模式|
|com.javapatterns.interpreter|解释器模式|
|com.javapatterns.mediator|调停者模式|
