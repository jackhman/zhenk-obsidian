> 亦称：事件订阅者、监听者、Event-Subscriber、Listener、Observer、**事件处理模型**、Hook、CallBack（钩子函数：JavaScript、Python、C、C++里面可以把一个函数当成一个对象传到一个方法参数里面）
> * 发布-订阅（Publish/Subscribe）模式
> * 模型-视图（Model/View）模式
> * 源-监听器（Source/Listener）模式
> * 从属者（Dependents）模式

> [!TIPS] 简介
> * 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
> * 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
> * 观察者以集合形式聚合遍历调用抽象观察者接口方法到被观察者中。
> * 观察者模式就是多态的一个运用，定义一个接口让其子类去实现，Observer之间会经常串在一起这时候就需要使用责任链模式来串起来中断某个event。


![[观察者模式原理图.png]]

## 结构
![[观察者模式结构图.png]]

### 角色
![[观察者模式的三个角色.png]]
* Source：事件源对象（被观察者），发生事件的对象。需要维护观察者list
* Observer Listener：观察者，等待事件的对象。根据某一个Event做出不同的反应
* Event：事件本身
> [!WAING] 注意
> 1. 有很多时候，观察者需要根据事件的具体情况来进行处理，在处理事件的时候，需要事件源对象（因为观察者需要监听事件源发生的事件做出反应）
> 2. 观察者需要存到事件源中去，观察事件源发生的事件做出反应（不同事件源也可以是相同反应动作）
> 3. 一个观察者监听多个事件源，事件源也可以发生不同类型事件，事件源和事件观察者以及事件之间耦合度没那么强
> 4. 事件也可以形成继承体系，也就是事件本身就可以有好多的类型：KeyEvent -> InputEvent -> ComponentEvent -> AWTEvent -> EventObject


> [!INFO] 事件源对象怎么传递给观察者
> 如果是在new Observer的时候，事件源对象以参数形式传递给观察者，这时候观察者和事件源对象绑定在一起了。----》 在Event 事件对象中 聚合 事件源对象（getSource方法来获取事件源对象，有很多的Observer具体的处理过程会根据事件源对象的不同而不同）
![[image-20231206191635386.png]]

## 优点
- _开闭原则_。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。
-  你可以在运行时建立对象之间的联系。

## 缺点
多态：被观察者中聚合了好多观察者对象。观察者做出的反应不一定要耦合到某一个特定的被观察者对象上，所以需要使用观察者模式
-  订阅者的通知顺序是**随机**的。

## 应用
* JavaScript中的Handle：事件监听器也就是Observer观察者，拿到事件对象之后进行处理。  
在 JavaScript 中，通常通过事件处理函数的参数来获取事件源对象。事件处理函数的第一个参数通常是一个事件对象，你可以使用这个事件对象来获取事件源对象。在这个例子中，点击按钮后，事件处理函数 `handleClick` 会被调用，并通过 `event.target` 或 `event.srcElement` 来获取事件源对象。这个事件源对象就是触发事件的 DOM 元素，即按钮。

请注意，`event.target` 在现代浏览器中是常用的方式，而 `event.srcElement` 是为了兼容旧版本的 Internet Explorer。在实际开发中，你可以使用 `event.target` 来获取事件源对象。
```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Source Example</title>
</head>
<body>

<button id="myButton">Click me</button>

<script>
// 事件处理函数
function handleClick(event) {
    // 通过事件对象获取事件源对象
    var sourceElement = event.target || event.srcElement;

    // 在控制台打印事件源对象
    console.log("Event Source:", sourceElement);
}

// 获取按钮元素
var myButton = document.getElementById("myButton");

// 为按钮元素添加点击事件监听器
if (myButton.addEventListener) {
    myButton.addEventListener("click", handleClick);
} else if (myButton.attachEvent) {
    myButton.attachEvent("onclick", handleClick);
}
</script>

</body>
</html>
```


## 伪代码

```java
// 发布者基类包含订阅管理代码和通知方法。
class EventManager is
    private field listeners: hash map of event types and listeners

    method subscribe(eventType, listener) is
        listeners.add(eventType, listener)

    method unsubscribe(eventType, listener) is
        listeners.remove(eventType, listener)

    method notify(eventType, data) is
        foreach (listener in listeners.of(eventType)) do
            listener.update(data)

// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩
// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。
// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。
class Editor is
    public field events: EventManager
    private field file: File

    constructor Editor() is
        events = new EventManager()

    // 业务逻辑的方法可将变化通知给订阅者。
    method openFile(path) is
        this.file = new File(path)
        events.notify("open", file.name)

    method saveFile() is
        file.write()
        events.notify("save", file.name)

    // ……

// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整
// 个订阅者的层次结构。
interface EventListener is
    method update(filename)

// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。
class LoggingListener implements EventListener is
    private field log: File
    private field message: string

    constructor LoggingListener(log_filename, message) is
        this.log = new File(log_filename)
        this.message = message

    method update(filename) is
        log.write(replace('%s',filename,message))

class EmailAlertsListener implements EventListener is
    private field email: string
    private field message: string

    constructor EmailAlertsListener(email, message) is
        this.email = email
        this.message = message

    method update(filename) is
        system.email(email, replace('%s',filename,message))

// 应用程序可在运行时配置发布者和订阅者。
class Application is
    method config() is
        editor = new Editor()

        logger = new LoggingListener(
            "/path/to/log.txt",
            "有人打开了文件：%s");
        editor.events.subscribe("open", logger)

        emailAlerts = new EmailAlertsListener(
            "admin@example.com",
            "有人更改了文件：%s")
        editor.events.subscribe("save", emailAlerts)
```