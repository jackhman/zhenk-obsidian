> [!TIP] 基本思想
> <font color = red>定义一系列（一簇）算法， 并将每种算法分别封装到独立的类中， 以使它们之间能够相互替换。某种动作采取不同的策略。</font>
> - 策略模式使得算法的改变独立于客户端（客户端和基类耦合）。
> - 捕获抽象的接口（基类），将具体的实现细节放到衍生类中。
>
> 优点：
> 1. 开闭原则
> 2. 避免使用多重条件转移语句
> 3. 方法中可以包含管理相关的算法族和替换继承关系的基类接口
> 
> 缺点：
> 1. 具体策略类会逐渐增多，可以通过享元模式减少对象的数量
> 2. 客户端必须知道所有策略类之间的区别，并自行决定使用哪一个策略类

将接口封装在一个基类里，将具体实现放到个衍生类中——下图展示了其原理。 客户端和基类耦合，而不用经历变化的动荡：衍生类的数量变了不会有影响；某个具体衍生类的实现改变了也不会有影响。
![[image-20231204185327483.png]]
- Comparable不是一个策略模式，因为实现  compareTo 方法中的算法也要灵活指定
- 而Comparator是实现Comparable的子类来指定两个对象之间的比较大小，是一种策略模式，其中抽象方法为必须实现的方法`int compare(T o1, T o2)`
- 比较策略必须都要实现  compare 方法，不同实现方法决定不同策略
- 准备一组算法，并将每一个算法封装起来，使得它们可以互换
## 模式动机
- 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
- 在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
- 在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
- 除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。
- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

## 模型结构
策略模式包含如下角色：
- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类

![../_images/Strategy.jpg](_images!Strategy.jpg)

![[策略模式结构.png]]

## 时序图

![../_images/seq_Strategy.jpg](_images!seq_Strategy.jpg)


## 实例
这里有一些核心 Java 程序库中策略模式的示例：

- 对 [`java.util.Comparator#compare()`](http://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#compare-T-T-) 的调用来自 `Collections#sort()`.
- [`javax.servlet.http.HttpServlet`](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html)： ​ `service­()`方法， 还有所有接受 `Http­Servlet­Request`和 `Http­Servlet­Response`对象作为参数的 `do­XXX()`方法。
- [`javax.servlet.Filter#doFilter()`](http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)

**识别方法**： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。