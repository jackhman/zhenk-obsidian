1. 假设一个订单的编号规则是AAAAOrder2020-0000001，AAAAOrder2020-0000002....后面的数字是自增长，如果订单号码达到AAAAOrder2020-1000000(100万)，数据库中应该有100万条数据，此时我随机删除2条数据（物理删除，且不考虑日志和备份），请问怎么找到删掉的数据的编号？给出解题思路即可，答案需要在1秒内运行得到? 答案：
    
2. shardingJDBC 它里面的内部原理，大概就是将sql拿过来，它自己内部进行一下解析，然后根据分片决定sql走到哪个表，哪个库。？？ 关键的是这个解析sql ，所以，他内部会有一个缓存。缓存sql，但是，缓存的sql值，用的是?代替。就是占位符。就是mybatis中的，占位符我一个同事这样写。#是占位符,?是拼接。sharding识别不了?,那么sharding就会一直拼接这个。 拼到最后，就变成这样
    
3. entry count
4. 

## Dubbo中的SPI和Java中的SPI区别

1. Dubbo是可自适应扩展需要的实例对象，而Java是全部加载
2. Dubbo添加了AOP和IOC的特性、
3. Adaptive注解到需要代理的接口类方法上实现**自适应扩展机制**
```xml
getExtension(String name)  #根据key获取拓展对象
    -->createExtension(String name) #创建拓展实例
        -->getExtensionClasses #根据路径获取所有的拓展类
            -->loadExtensionClasses #加载拓展类
                -->cacheDefaultExtensionName #解析@SPI注解
            -->loadDirectory #方法加载指定文件夹配置文件
                -->loadResource #加载资源
                    -->loadClass #加载类，并通过 loadClass 方法对类进行缓存
```

## MySQL索引失效的情况

## 什么是分布式事务以及它的主要作用

## [阿里面试题]深度理解BIO和NIO的原理与区别

## [美团面试题]BloomFilter解决缓存穿透的底层原理

## [京东面试题]如果理解令牌桶、漏桶等限流算法

## [字节面试题]什么是最大努力通知型数据一致性方案

## [快手面试题]Spring Boot Starter实现原理

## [拼夕夕面试题]JVM垃圾回收器的类型与实现原理

## [易诚互动]SpringBoot怎么自动配置

## [易诚互动]介绍JMM

## [易诚互动]设计模式

## Nacos服务之间的发现和调用

## A调用B


## Sharding
Sharding需要把所有的数据源都要配置

## Spring
### Spring事件监听的核心机制
Spring事件监听机制是基于观察者模式的，它允许你的应用在发生某个特定事件时执行一些自定义逻辑。大的应用是使用MQ来对业务之间的解耦。这个机制包括三个主要部分：事件（Events）、监听器（Listeners）和事件发布者（Event Publishers）。SpringCloud或者SpringBoot等微服务框架与Spring集成都用到了Spring的监听器进行扩展。下面是Spring事件监听机制的核心组成及其工作原理：

#### 1. 事件（Events）
在Spring框架中，所有的事件都必须扩展自`ApplicationEvent`类。这个类包含了事件发生时的时间戳和其他基本信息。你可以创建自定义事件，通过扩展`ApplicationEvent`类来包含特定于你的应用的数据。
```java
public class CustomEvent extends ApplicationEvent {
    public CustomEvent(Object source) {
        super(source);
    }
    // 添加自定义方法和属性
}
```


#### 2. 监听器（Listeners）

监听器是实现了`ApplicationListener`接口的任何Spring管理的bean，它重写了`onApplicationEvent`方法来定义当监听到事件时的行为。Spring 4.2引入了基于注解的事件监听器，允许使用`@EventListener`注解来标注任意方法作为事件监听器，而不必实现`ApplicationListener`接口。

```java
@Component
public class CustomEventListener implements ApplicationListener<CustomEvent> {
    @Override
    public void onApplicationEvent(CustomEvent event) {
        // 处理事件
    }
}

// 或使用@EventListener注解
@Component
public class AnotherEventListener {

    @EventListener
    public void handleCustomEvent(CustomEvent event) {
        // 处理事件
    }
}
```

#### 3. 事件发布者（Event Publishers）

Spring应用上下文（`ApplicationContext`）充当事件发布者。你可以在应用的任何部分注入`ApplicationContext`并使用它来发布事件。

```java
@Component
public class CustomEventPublisher {
    @Autowired
    private ApplicationContext applicationContext;

    public void publishEvent() {
        CustomEvent customEvent = new CustomEvent(this);
        applicationContext.publishEvent(customEvent);
    }
}
```
#### 工作原理

1. **事件定义**：首先，定义一个或多个扩展自`ApplicationEvent`的事件类。
2. **监听器注册**：然后，创建并注册一个或多个监听器，这些监听器通过实现`ApplicationListener`接口或使用`@EventListener`注解来指定它们对哪些事件感兴趣。
3. **事件发布**：在应用的任何地方，你可以通过Spring应用上下文来发布事件。Spring容器将负责将事件传递给所有对该事件感兴趣的监听器。

这种事件驱动的机制可以使应用组件之间的通信更加松散耦合，增加了代码的灵活性和可维护性。通过使用Spring的事件监听机制，应用可以在保持组件独立的同时，响应并处理各种事件。

### [Spring事务失效场景](Spring#事务失效场景)
1. **异常类型不正确**：默认情况下，只有在抛出运行时异常（`RuntimeException`）和错误（`Error`）时，Spring才会回滚事务。如果方法抛出的是检查型异常（非`RuntimeException`的异常），且没有通过`@Transactional`的`rollbackFor`属性明确指定回滚异常，事务不会回滚。
2. **事务传播行为不正确**：`@Transactional`注解提供了不同的事务传播行为选项，如`REQUIRED`、`REQUIRES_NEW`等。如果调用方法的事务传播行为与当前事务环境不兼容，可能导致事务失效。
3. **自调用问题**：在同一个类中的一个方法直接调用另一个带有`@Transactional`注解的方法时，事务不会生效。这是因为事务的代理是基于AOP的，而自调用不会通过代理。
4. **方法不是通过Spring管理的Bean调用**：`@Transactional`只有在通过Spring的ApplicationContext来调用方法时才有效。如果是直接从一个普通方法内部调用另一个带有`@Transactional`注解的方法，事务是不会生效的。
5. **配置错误**：Spring的配置问题，比如没有启用事务管理器，或者`@Transactional`注解没有被正确扫描到等，也会导致事务失效。确保你的Spring配置中启用了注解事务管理。在Spring Boot应用中，这通常是自动配置的，但在某些老旧或自定义配置的Spring应用中，可能需要手动配置。`@EnableTransactionManagement` 注解确保能够识别 `@Transactional` 注解。
6. **方法访问级别不正确**：`@Transactional`注解通常应用于公共方法。将`@Transactional`应用于非公共方法可能导致事务失效，因为代理机制可能无法正确应用于非公共方法。这是因为Spring使用动态代理来实现事务管理，而对于基于JDK动态代理的情况，只能代理公开的接口方法；对于基于CGLIB的代理，虽然能代理protected、private或包级私有方法，但这是不推荐的做法，因为它可能导致非预期的行为。
7. **数据库或JPA提供者不支持事务**：如果使用的数据库或JPA提供者（如Hibernate）不支持当前配置的事务类型或事务管理不当，也可能导致事务失效。
8. **事务管理器选择错误**：如果在多数据源环境中，没有指定正确的事务管理器，也可能导致事务不生效。
9. **多线程问题**：每一个线程对应的JDBC Connection对象都是单独各自的保存在自己的ThreadLocal对象中，如果想共享数据库连接池的话可以通过编程式事务或者通过分布式事务的解决方法（2PC或者3PC）