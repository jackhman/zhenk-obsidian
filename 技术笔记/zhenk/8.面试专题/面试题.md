1. 假设一个订单的编号规则是AAAAOrder2020-0000001，AAAAOrder2020-0000002....后面的数字是自增长，如果订单号码达到AAAAOrder2020-1000000(100万)，数据库中应该有100万条数据，此时我随机删除2条数据（物理删除，且不考虑日志和备份），请问怎么找到删掉的数据的编号？给出解题思路即可，答案需要在1秒内运行得到? 答案：
    
2. shardingJDBC 它里面的内部原理，大概就是将sql拿过来，它自己内部进行一下解析，然后根据分片决定sql走到哪个表，哪个库。？？ 关键的是这个解析sql ，所以，他内部会有一个缓存。缓存sql，但是，缓存的sql值，用的是?代替。就是占位符。就是mybatis中的，占位符我一个同事这样写。#是占位符,?是拼接。sharding识别不了?,那么sharding就会一直拼接这个。 拼到最后，就变成这样
    
3. entry count
4. 

## Dubbo中的SPI和Java中的SPI区别

1. Dubbo是可自适应扩展需要的实例对象，而Java是全部加载
2. Dubbo添加了AOP和IOC的特性、
3. Adaptive注解到需要代理的接口类方法上实现**自适应扩展机制**
```xml
getExtension(String name)  #根据key获取拓展对象
    -->createExtension(String name) #创建拓展实例
        -->getExtensionClasses #根据路径获取所有的拓展类
            -->loadExtensionClasses #加载拓展类
                -->cacheDefaultExtensionName #解析@SPI注解
            -->loadDirectory #方法加载指定文件夹配置文件
                -->loadResource #加载资源
                    -->loadClass #加载类，并通过 loadClass 方法对类进行缓存
```

## MySQL索引失效的情况
1. **未使用索引的列：** 查询中涉及的列没有被索引，或者查询条件中包含了不可被索引的列。确保你的查询条件中使用了适当的索引列。
```SQL
-- 错误的例子：没有使用索引的列 
SELECT * FROM mytable WHERE non_indexed_column = 'value';  
-- 正确的例子：使用了索引的列 
SELECT * FROM mytable WHERE indexed_column = 'value';
```

2. **模糊查询：%的使用：** 在查询中使用`LIKE`并以通配符`%`开头的模糊查询可能导致索引失效，因为通配符在开头时索引无法被有效使用。
```SQL
-- 错误的例子：以%开头的模糊查询 
SELECT * FROM mytable WHERE column LIKE '%value';  
-- 正确的例子：避免以%开头 
SELECT * FROM mytable WHERE column LIKE 'value%';
```

3. **函数的使用：** 如果在查询条件中使用了函数，可能会导致索引失效。例如，在索引列上使用函数会阻止优化器使用索引。
```SQL
-- 错误的例子：使用了函数 
SELECT * FROM mytable WHERE UPPER(column) = 'VALUE';  
-- 正确的例子：避免在索引列上使用函数 
SELECT * FROM mytable WHERE column = 'value';
```

4. **数据类型不匹配：** 如果查询条件中的数据类型与索引列的数据类型不匹配，索引可能无法被使用。
```SQL
-- 错误的例子：数据类型不匹配 
SELECT * FROM mytable WHERE indexed_column = '123';  
-- 正确的例子：保持数据类型一致 
SELECT * FROM mytable WHERE indexed_column = 123;
```

5. **复合索引的顺序：** 对于复合索引（包含多个列的索引），查询条件中列的顺序应该与索引的顺序一致，否则索引可能无法被利用。
```SQL
-- 错误的例子：查询条件列的顺序与复合索引不一致 
SELECT * FROM mytable WHERE indexed_column2 = 'value' AND indexed_column1 = 'another_value';  
-- 正确的例子：查询条件列的顺序与复合索引一致 
SELECT * FROM mytable WHERE indexed_column1 = 'another_value' AND indexed_column2 = 'value';
```

6. **表统计信息过时：** 如果表的统计信息过时，优化器可能做出不准确的决策。你可以使用`ANALYZE TABLE`命令更新统计信息。
```SQL
ANALYZE TABLE mytable;
```

7. **数据分布不均匀：** 如果表中的数据分布不均匀，即某些值的重复性很高，优化器可能选择不使用索引。在这种情况下，可能需要重新设计索引或考虑其他优化策略。

定位索引失效的具体原因可能需要查看查询执行计划（EXPLAIN），以便了解MySQL优化器的决策过程。通过分析执行计划，你可以确定是否使用了索引，以及哪些步骤导致了索引失效。

8. **索引选择不当：** MySQL可能有多个可用索引，但优化器选择了不是最佳的索引。这可能是因为统计信息不准确，导致优化器做出错误的选择。使用`ANALYZE TABLE`可以更新统计信息。此外，可以通过使用`FORCE INDEX`提示强制选择特定的索引。
```SQL    
-- 强制使用特定的索引 
SELECT * FROM mytable FORCE INDEX (index_name) WHERE indexed_column = 'value';
```

9. **数据量过大：** 当表的数据量很大时，即使有索引，查询可能仍然会变得很慢。在这种情况下，考虑使用分区表、垂直切分或其他数据分片策略来减少单个查询的数据量。

10. **OR条件：** 在查询中使用多个`OR`条件可能导致索引失效。优化器可能无法同时使用多个索引。尽量避免使用多个`OR`条件，或者考虑使用联合索引。
 ```SQL
 -- 错误的例子：多个OR条件 
 SELECT * FROM mytable WHERE column = 'value1' OR column = 'value2';  
 -- 正确的例子：使用IN来替代多个OR条件 
 SELECT * FROM mytable WHERE column IN ('value1', 'value2');
 ```
   
11. **JOIN操作：** 在连接操作中，确保连接的列上有索引。否则，连接可能会导致性能下降。
```SQL
-- 确保连接的列有索引 
SELECT * FROM table1 JOIN table2 ON table1.indexed_column = table2.indexed_column;
```

12. **子查询：** 在子查询中使用索引可能会有问题，特别是在MySQL版本较早的情况下。考虑使用`JOIN`来替代子查询。
```SQL
-- 使用JOIN替代子查询 
SELECT * FROM mytable JOIN (SELECT id FROM anothertable WHERE condition) AS subquery ON mytable.id = subquery.id;
```
   
13. **高并发情况：** 在高并发环境下，锁和资源争夺可能导致索引失效。考虑使用更高级的数据库架构，例如分布式数据库或缓存。
14. **表碎片：** 表碎片可能会导致性能下降，包括索引的性能。定期进行表优化操作可以帮助修复碎片。
```SQL
OPTIMIZE TABLE mytable;
```    

总体而言，理解查询执行计划、监控数据库性能、适时更新统计信息、考虑数据分布和合理设计索引是保持MySQL索引高效的关键。优化数据库性能是一个综合的过程，需要结合具体的业务场景和数据库结构来进行调优。

## 什么是分布式事务以及它的主要作用

## Nacos服务之间的发现和调用

## A调用B


## Sharding
Sharding需要把所有的数据源都要配置

## Spring
### Spring事件监听的核心机制
Spring事件监听机制是基于观察者模式的，它允许你的应用在发生某个特定事件时执行一些自定义逻辑。大的应用是使用MQ来对业务之间的解耦。这个机制包括三个主要部分：事件（Events）、监听器（Listeners）和事件发布者（Event Publishers）。SpringCloud或者SpringBoot等微服务框架与Spring集成都用到了Spring的监听器进行扩展。下面是Spring事件监听机制的核心组成及其工作原理：

#### 1. 事件（Events）
在Spring框架中，所有的事件都必须扩展自`ApplicationEvent`类。这个类包含了事件发生时的时间戳和其他基本信息。你可以创建自定义事件，通过扩展`ApplicationEvent`类来包含特定于你的应用的数据。
```java
public class CustomEvent extends ApplicationEvent {
    public CustomEvent(Object source) {
        super(source);
    }
    // 添加自定义方法和属性
}
```


#### 2. 监听器（Listeners）

监听器是实现了`ApplicationListener`接口的任何Spring管理的bean，它重写了`onApplicationEvent`方法来定义当监听到事件时的行为。Spring 4.2引入了基于注解的事件监听器，允许使用`@EventListener`注解来标注任意方法作为事件监听器，而不必实现`ApplicationListener`接口。

```java
@Component
public class CustomEventListener implements ApplicationListener<CustomEvent> {
    @Override
    public void onApplicationEvent(CustomEvent event) {
        // 处理事件
    }
}

// 或使用@EventListener注解
@Component
public class AnotherEventListener {

    @EventListener
    public void handleCustomEvent(CustomEvent event) {
        // 处理事件
    }
}
```

#### 3. 事件发布者（Event Publishers）

Spring应用上下文（`ApplicationContext`）充当事件发布者。你可以在应用的任何部分注入`ApplicationContext`并使用它来发布事件。

```java
@Component
public class CustomEventPublisher {
    @Autowired
    private ApplicationContext applicationContext;

    public void publishEvent() {
        CustomEvent customEvent = new CustomEvent(this);
        applicationContext.publishEvent(customEvent);
    }
}
```
#### 工作原理

1. **事件定义**：首先，定义一个或多个扩展自`ApplicationEvent`的事件类。
2. **监听器注册**：然后，创建并注册一个或多个监听器，这些监听器通过实现`ApplicationListener`接口或使用`@EventListener`注解来指定它们对哪些事件感兴趣。
3. **事件发布**：在应用的任何地方，你可以通过Spring应用上下文来发布事件。Spring容器将负责将事件传递给所有对该事件感兴趣的监听器。

这种事件驱动的机制可以使应用组件之间的通信更加松散耦合，增加了代码的灵活性和可维护性。通过使用Spring的事件监听机制，应用可以在保持组件独立的同时，响应并处理各种事件。

### [Spring事务失效场景](Spring#事务失效场景)
1. **异常类型不正确**：默认情况下，只有在抛出运行时异常（`RuntimeException`）和错误（`Error`）时，Spring才会回滚事务。如果方法抛出的是检查型异常（非`RuntimeException`的异常），且没有通过`@Transactional`的`rollbackFor`属性明确指定回滚异常，事务不会回滚。
2. **事务传播行为不正确**：`@Transactional`注解提供了不同的事务传播行为选项，如`REQUIRED`、`REQUIRES_NEW`等。如果调用方法的事务传播行为与当前事务环境不兼容，可能导致事务失效。
3. **自调用问题**：在同一个类中的一个方法直接调用另一个带有`@Transactional`注解的方法时，事务不会生效。这是因为事务的代理是基于AOP的，而自调用不会通过代理。
4. **方法不是通过Spring管理的Bean调用**：`@Transactional`只有在通过Spring的ApplicationContext来调用方法时才有效。如果是直接从一个普通方法内部调用另一个带有`@Transactional`注解的方法，事务是不会生效的。
5. **配置错误**：Spring的配置问题，比如没有启用事务管理器，或者`@Transactional`注解没有被正确扫描到等，也会导致事务失效。确保你的Spring配置中启用了注解事务管理。在Spring Boot应用中，这通常是自动配置的，但在某些老旧或自定义配置的Spring应用中，可能需要手动配置。`@EnableTransactionManagement` 注解确保能够识别 `@Transactional` 注解。
6. **方法访问级别不正确**：`@Transactional`注解通常应用于公共方法。将`@Transactional`应用于非公共方法可能导致事务失效，因为代理机制可能无法正确应用于非公共方法。这是因为Spring使用动态代理来实现事务管理，而对于基于JDK动态代理的情况，只能代理公开的接口方法；对于基于CGLIB的代理，虽然能代理protected、private或包级私有方法，但这是不推荐的做法，因为它可能导致非预期的行为。
7. **数据库或JPA提供者不支持事务**：如果使用的数据库或JPA提供者（如Hibernate）不支持当前配置的事务类型或事务管理不当，也可能导致事务失效。
8. **事务管理器选择错误**：如果在多数据源环境中，没有指定正确的事务管理器，也可能导致事务不生效。
9. **多线程问题**：每一个线程对应的JDBC Connection对象都是单独各自的保存在自己的ThreadLocal对象中，如果想共享数据库连接池的话可以通过编程式事务或者通过分布式事务的解决方法（2PC或者3PC）
