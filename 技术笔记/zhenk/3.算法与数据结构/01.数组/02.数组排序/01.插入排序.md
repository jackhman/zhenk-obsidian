>[!tip] **插入排序（Insertion Sort）基本思想**
>* 将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间(一直会保存有序状态)的适当位置。

![[插入排序原理动图.gif]]

## 工作原理

- 把一系列数字放在一个未排序的堆里。
- 从堆中挑选一个数字。 你选择哪一个并不重要，但从堆顶挑选是最容易。
- 把这个数插入一个新的数组。
- 从未排序堆中再选择一个数字，并将其插入之前的数组中。 这个数字在第一个数字之前或之后，所以现在这两个数字被排序。
- 再从堆中选择一个数字，并将其插入到数组中的正确排序位置
- 继续这样做，直到堆里没有数字。 最终得到一个空堆和一个排序的数组。
![[插入排序静态图.png]]

## 算法分析

- **最佳时间复杂度**：$O(n)$。最好的情况下（初始时区间已经是升序排列），每个元素只进行一次元素之间的比较，因而总的比较次数最少，为 $∑^n_{i = 2}1 = n − 1$，并不需要移动元素（记录），这是最好的情况。
- **最差时间复杂度**：$O(n^2)$。最差的情况下（初始时区间已经是降序排列），每个元素 $nums[i]$ 都要进行 $i - 1$ 次元素之间的比较，元素之间总的比较次数达到最大值，为 $∑^n_{i=2}(i − 1) = \frac{n(n−1)}{2}$。
- **平均时间复杂度**：$O(n^2)$。如果区间的初始情况是随机的，即参加排序的区间中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 $\frac{n^2}{4}$。由此得知，插入排序算法的平均时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(1)$。插入排序算法为原地排序算法，只用到指针变量 $i$、$j$ 以及表示无序区间中第 $1$ 个元素的变量等常数项的变量。
- **排序稳定性**：在插入操作过程中，每次都讲元素插入到相等元素的右侧，并不会改变相等元素的相对顺序。因此，插入排序方法是一种 **稳定排序算法**。

## 代码实现
```java
public static void insertionSort(int[] arr) {  
    // 有序数组0开始  
    for (int i = 1; i < arr.length; i++) {  
        for (int j = i; j > 0; j--) {  
            if (arr[j] < arr[j - 1]) {  
                swap(arr, j, j - 1);  
            }  
        }  
    }  
    print(arr);  
}
```