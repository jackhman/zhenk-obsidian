
>[!tip] **计数排序（Counting Sort）基本思想**：
>通过统计数组中每个元素在数组中出现的次数，根据这些统计信息将数组元素有序的放置到正确位置，从而达到排序的目的。

### 应用场景
> [!TIP] 算法思想
> 量大但范围小
1. 某大型企业数万名员工年龄排序
2. 如何快速得知高考名次

## 算法步骤
1. **计算排序范围**：遍历数组，找出待排序序列中最大值元素 $nums\underline{}max$ 和最小值元素 $nums\underline{}min$，计算出排序范围为 $nums\underline{}max - nums\underline{}min + 1$。
2. **定义计数数组**：定义一个大小为排序范围的计数数组 $counts$，用于统计每个元素的出现次数。其中：
   1. 数组的索引值 $num - nums\underline{}min$ 表示元素的值为 $num$。
   2. 数组的值 $counts[num - nums\underline{}min]$ 表示元素 $num$ 的出现次数。

3. **对数组元素进行计数统计**：遍历待排序数组 $nums$，对每个元素在计数数组中进行计数，即将待排序数组中「每个元素值减去最小值」作为索引，将「对计数数组中的值」加 $1$，即令 $counts[num - nums\underline{}min]$ 加 $1$。
4. **生成累积计数数组**：从 $counts$ 中的第 $1$ 个元素开始，每一项累家前一项和。此时 $counts[num - nums\underline{}min]$ 表示值为 $num$ 的元素在排序数组中最后一次出现的位置。
5. **逆序填充目标数组**：逆序遍历数组 $nums$，将每个元素 $num$ 填入正确位置。
  1. 将其填充到结果数组 $res$ 的索引 $counts[num - nums\underline{}min]$ 处。
  2. 放入后，令累积计数数组中对应索引减 $1$，从而得到下个元素 $num$ 的放置位置。

## 算法分析
* **时间复杂度**：$O(n + k)$。其中 $k$ 代表待排序数组的值域，也就是计数数组的长度；其中 $n$ 代表的是原数组长度 。
- **空间复杂度**：$O(k)$。其中 $k$ 代表待排序序列的值域。由于用于计数的数组 $counts$ 的长度取决于待排序数组中数据的范围（大小等于待排序数组最大值减去最小值再加 $1$）。所以计数排序算法对于数据范围很大的数组，需要大量的内存。
- **计数排序适用情况**：计数排序一般用于整数排序，不适用于按字母顺序、人名顺序排序。
- **排序稳定性**：由于向结果数组中填充元素时使用的是逆序遍历，可以避免改变相等元素之间的相对顺序。因此，计数排序是一种 **稳定排序算法**。

## 代码实现
```java
public class CountSort {  
    public static void main(String[] args) {  
        int[] array = {7, 3, 2, 10, 8, 1, 9, 5, 4, 6};  
        sort(array);  
        print(array);  
    }  
  
    public static void sort(int[] array) {  
        if (array == null || array.length == 0) {  
            return;  
        }  
        // 1. 计算出最大和最小值 并算出其区间  
        int max = Arrays.stream(array).max().getAsInt();  
        int min = Arrays.stream(array).min().getAsInt();  
        int range = max - min + 1;  
        // 2. 初始化计数数组   
        int[] count = new int[range];  
        int[] output = new int[array.length];  
        // 3. 统计每个元素的出现次数  
        for (int m = 0; m < array.length; m++) {  
            count[array[m] - min]++;  
        }  
  
        // 将统计信息累加，得到每个元素的正确位置  
        for (int m = 1; m < range; m++) {  
            count[m] += count[m - 1];  
        }  
  
        // 将元素按正确位置放入输出数组  
        for (int m = array.length - 1; m >= 0; m--) {  
            output[count[array[m] - min] - 1] = array[m];  
            count[array[m] - min]--;  
        }  
  
        // 将输出数组拷贝回原数组  
        System.arraycopy(output, 0, array, 0, array.length);  
    }  
}
```