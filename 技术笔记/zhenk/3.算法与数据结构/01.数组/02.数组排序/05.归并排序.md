## 1. 归并排序算法思想
> [!TIP] 归并排序**（Merge Sort）**算法思想
> 采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。递归算法中一定有个base case 来跳出循环。

![[归并排序动图.gif]]

1945年，约翰·冯·诺依曼（John von Neumann）发明了归并排序，这是典型的分治算法的应用。

## 定义
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

## 算法思路
归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。

1. 将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。
2. 将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。
## 图解算法
假设我们有一个初始数列为{8, 4, 5, 7, 1, 3, 6, 2}，整个归并排序的过程如下图所示。

### 分而治之
![[归并排序-分而治之.png]]
可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。

### 合并两个有序数组流程
再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。
![[归并排序合并图.png]]


## 动画展示
![[归并排序动图.gif]]

## 算法性能
速度仅次于快速排序。

### 时间复杂度
O(nlogn)。

### 空间复杂度
O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序。

### 稳定性
稳定。

## 代码实现
### C和C++
```c
void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex){
    int i = startIndex, j=midIndex+1, k = startIndex;
    while(i!=midIndex+1 && j!=endIndex+1) {
        if(sourceArr[i] > sourceArr[j])
            tempArr[k++] = sourceArr[j++];
        else
            tempArr[k++] = sourceArr[i++];
    }
    while(i != midIndex+1)
        tempArr[k++] = sourceArr[i++];
    while(j != endIndex+1)
        tempArr[k++] = sourceArr[j++];
    for(i=startIndex; i<=endIndex; i++)
        sourceArr[i] = tempArr[i];
}
 
//内部使用递归
void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex) {
    int midIndex;
    if(startIndex < endIndex) {
        midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int
        MergeSort(sourceArr, tempArr, startIndex, midIndex);
        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);
        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);
    }
}
 
int main(int argc, char * argv[]) {
    int a[8] = {50, 10, 20, 30, 70, 40, 80, 60};
    int i, b[8];
    MergeSort(a, b, 0, 7);
    for(i=0; i<8; i++)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
```

### Java
```java
package MergeSort;
public class MergeSort {   
    public static int[] mergeSort(int[] nums, int l, int h) {
        if (l == h)
            return new int[] { nums[l] };
         
        int mid = l + (h - l) / 2;
        int[] leftArr = mergeSort(nums, l, mid); //左有序数组
        int[] rightArr = mergeSort(nums, mid + 1, h); //右有序数组
        int[] newNum = new int[leftArr.length + rightArr.length]; //新有序数组
         
        int m = 0, i = 0, j = 0; 
        while (i < leftArr.length && j < rightArr.length) {
            newNum[m++] = leftArr[i] < rightArr[j] ? leftArr[i++] : rightArr[j++];
        }
        while (i < leftArr.length)
            newNum[m++] = leftArr[i++];
        while (j < rightArr.length)
            newNum[m++] = rightArr[j++];
        return newNum;
    }
    public static void main(String[] args) {
        int[] nums = new int[] { 9, 8, 7, 6, 5, 4, 3, 2, 10 };
        int[] newNums = mergeSort(nums, 0, nums.length - 1);
        for (int x : newNums) {
            System.out.println(x);
        }
    }
}
```

### Python
```python
def MergeSort(lists):
    if len(lists) <= 1:
        return lists
    num = int( len(lists) / 2 )
    left = MergeSort(lists[:num])
    right = MergeSort(lists[num:])
    return Merge(left, right)
 
def Merge(left,right):
    r, l=0, 0
    result=[]
    while l<len(left) and r<len(right):
        if left[l] <= right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    result += list(left[l:])
    result += list(right[r:])
    return result
 
print MergeSort([1, 2, 3, 4, 5, 6, 7, 90, 21, 23, 45])
```
### 其他栗子
```java
package com.zhenksoft.datastructures.sort;  
  
import static com.zhenksoft.datastructures.utils.SortUtils.print;  
  
/**  
 * @author chengxiao  
 * @date 2016/12/8  
 * 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。  
 * java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。  
 * 从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。  
 * 总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。  
 */  
public class MergeSort {  
    public static void main(String[] args) {  
        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};  
/*        sort(arr);  
        System.out.println(Arrays.toString(arr));*/  
  
 /*       System.out.println("Original Array: " + Arrays.toString(arr));        mergeSort(arr);        System.out.println("Sorted Array: " + Arrays.toString(arr));*/  
        int[] newNums = mergeSort(arr, 0, arr.length - 1);  
        print(newNums);  
    }  
  
    public static void sort(int[] arr) {  
        int[] temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间  
        sort(arr, 0, arr.length - 1, temp);  
    }  
  
    private static void sort(int[] arr, int left, int right, int[] temp) {  
        if (left < right) {  
            int mid = (left + right) / 2;  
            sort(arr, left, mid, temp);//左边归并排序，使得左子序列有序  
            sort(arr, mid + 1, right, temp);//右边归并排序，使得右子序列有序  
            merge(arr, left, mid, right, temp);//将两个有序子数组合并操作  
        }  
    }  
  
    private static void merge(int[] arr, int left, int mid, int right, int[] temp) {  
        int i = left;//左序列指针  
        int j = mid + 1;//右序列指针  
        int t = 0;//临时数组指针  
        while (i <= mid && j <= right) {  
            if (arr[i] <= arr[j]) {  
                temp[t++] = arr[i++];  
            } else {  
                temp[t++] = arr[j++];  
            }  
        }  
        while (i <= mid) {//将左边剩余元素填充进temp中  
            temp[t++] = arr[i++];  
        }  
        while (j <= right) {//将右序列剩余元素填充进temp中  
            temp[t++] = arr[j++];  
        }  
        t = 0;  
        //将temp中的元素全部拷贝到原数组中  
        while (left <= right) {  
            arr[left++] = temp[t++];  
        }  
    }  
  
    public static void mergeSort(int[] array) {  
        if (array == null || array.length <= 1) {  
            return; // 已经有序或为空，无需排序  
        }  
  
        int n = array.length;  
        int[] temp = new int[n];  
        mergeSortHelper(array, temp, 0, n - 1);  
    }  
  
    private static void mergeSortHelper(int[] array, int[] temp, int left, int right) {  
        if (left < right) {  
            int middle = (left + right) / 2;  
  
            // 递归地对左右两部分进行归并排序  
            mergeSortHelper(array, temp, left, middle);  
            mergeSortHelper(array, temp, middle + 1, right);  
  
            // 合并两个已排序的子数组  
            merge(array, temp, left, middle, right);  
        }  
    }  
  
    /**  
     * @param array  原来数组  
     * @param temp   临时数组  
     * @param left   左指针  
     * @param middle 中间指针  
     * @param right  右指针  
     */  
    private static void merge(int[] array, int[] temp, int left, int middle, int right) {  
        int i = left;  
        int j = middle + 1;  
        int k = left;  
  
        // 合并两个子数组  
        while (i <= middle && j <= right) {  
            if (array[i] <= array[j]) {  
                temp[k++] = array[i++];  
            } else {  
                temp[k++] = array[j++];  
            }  
        }  
  
        // 将左边剩余元素复制到临时数组  
        while (i <= middle) {  
            temp[k++] = array[i++];  
        }  
  
        // 将右边剩余元素复制到临时数组  
        while (j <= right) {  
            temp[k++] = array[j++];  
        }  
  
        // 将临时数组的元素复制回原数组  
/*        for (i = left; i <= right; i++) {  
            array[i] = temp[i];        }*/  
        // 将临时数组的元素复制回原数组  
        System.arraycopy(temp, left, array, left, right - left + 1);  
    }  
  
    /**  
     * @param nums 需要排序的数组  
     * @param l    左指针  
     * @param h    右指针  
     * @return 排好序的数组  
     */  
    public static int[] mergeSort(int[] nums, int l, int h) {  
        if (l == h) {  
            return new int[]{nums[l]};  
        }  
  
        int mid = l + (h - l) / 2;  
        //左有序数组  
        int[] leftArr = mergeSort(nums, l, mid);  
        //右有序数组  
        int[] rightArr = mergeSort(nums, mid + 1, h);  
        //新有序数组  
        int[] newNum = new int[leftArr.length + rightArr.length];  
  
        int m = 0, i = 0, j = 0;  
        while (i < leftArr.length && j < rightArr.length) {  
            newNum[m++] = leftArr[i] < rightArr[j] ? leftArr[i++] : rightArr[j++];  
        }  
        while (i < leftArr.length) {  
            newNum[m++] = leftArr[i++];  
        }  
        while (j < rightArr.length) {  
            newNum[m++] = rightArr[j++];  
        }  
        return newNum;  
    }  
}
```