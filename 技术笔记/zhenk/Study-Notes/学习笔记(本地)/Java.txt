  脏读(Dirty Read)： 

事务T1更新了数据还未提交，这时事务T2来读取相同的数据，则T2读到的数据其实是错误的数据，即脏数据。基于脏数据所作的操作是不可能正确的 

  丢失更新：（Lost Update） 

事务T1读取了数据，并执行了一些操作，然后更新数据。事务T2也做相同的事，则T1和T2更新数据时可能会覆盖对方的更新，从而引起错误。 

  不可重复读（Nonrepeatable Read） 

一个事务的两次读取中，读取相同的资源得到不同的值。当事务T2在事务T1的两次读取之间更新数据，则会发生此种错误（重点在修改） 

  幻读（Phantom）： 
事务T1对一定范围内执行操作，T2对相同的范围内执行不兼容的操作，这时会发生幻读。 
如：T1删除符合条件C1的所有数据，T2又插入了一些符合条件C1的数据，则在T1中再次查找符合条件C1的数据还是可以查到，这对T1来说好像是幻觉一样，这时的读取操作称为幻读。（重点在新增或删除）

1.事务是什么？有哪些属性，并简要说明这些属性的含义。


  解答：事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起，并用形如begin transaction和end transaction语句（或函数调用）来界定。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。
事务应该具有4个属性：原子性、一致性、隔离性、持续性。这四个属性通常称为ACID特性。


原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。


一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。


持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。





2.Collection 和 Collections的区别？


   解答：Collection是java.util下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List；Collections是个java.util下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。


3.HashMap与TreeMap的区别？
解答：HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。

1.HashMap与TreeMap的区别？

  
解答：HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。




2.ArrayList和Vector的区别？

 
 解答：同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程不安全的，不是同步的；数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半。




3.HashMap和Hashtable的区别？

  
解答：HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都实现了Map接口，主要区别
在于HashMap允许空（null）键值（key）,由于非线程安全，效率上高于Hashtable。HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。最大的不同是，Hastable的方法是synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供同步。

1.请说出 ArrayList,Vector, LinkedList 的存储性能和特性


  解答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加
和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以
索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较
ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但
是插入数据时只需要记录本项的前后项即可，所以插入速度较快。




2.简单说明什么是递归？什么情况会使用？并使用 java 实现一个简单的递归程序。


  解答：
1）递归做为一种算法在程序设计语言中广泛应用.是指函数/过程/子程序在运行过程中直接或间接调
用自身而产生的重入现象。
2）递归算法一般用于解决三类问题：
a.数据的定义是按递归定义的。(Fibonacci（斐波那契）函数)
b.问题解法按递归算法实现。(回溯)
c.数据的结构形式是按递归定义的。(树的遍历，图的搜索)
3）.这是一个排列的例子，它所做的工作是将输入的一个字符串中的所有元素进行排序并输出，例如：
你给出的参数是"abc" 则程序会输出：
abc
acb
bac
bca
cab
cba
a.算法的出口在于：ｌｏｗ＝ｈｉｇｈ也就是现在给出的排列元素只有一个时。
b.算法的逼近过程：先确定排列的第一位元素，也就是循环中ｉ所代表的元素，
然后ｌｏｗ＋１开始减少排列元素，如此下去，直到ｌｏｗ＝ｈｉｇｈ

  public class Foo {

    public static void main(String[] args) {

    permute("abc");
}

    public static void permute(String str) {

     char[] strArray = str.toCharArray();

     permute(strArray, 0, strArray.length - 1);

   }

  public static void permute(char[] list, int low, int high) {

   int i;

if (low == high) {
String cout = "";
for (i = 0; i <= high; i++)
cout += list[i];
System.out.println(cout);
} else {
for (i = low; i <= high; i++) {
char temp = list[low];
list[low] = list[i];
list[i] = temp;
permute(list, low + 1, high);
temp = list[low];
list[low] = list[i];
list[i] = temp;
}
}
}
}




3.列出自己常用的 jdk 包


   解答：JDK 常用的 package
java.lang： 这个是系统的基础类，比如 String 等都是这里面的，这个 package 是唯一一个可以不
用 import 就可以使用的 Package
java.io: 这里面是所有输入输出有关的类，比如文件操作等
java.net: 这里面是与网络有关的类，比如 URL,URLConnection 等。
java.util : 这个是系统辅助类，特别是集合类 Collection,List,Map 等。
java.sql: 这个是数据库操作的类，Connection, Statememt，ResultSet 等

1.Hibernate中：不看数据库，不看XML文件，不看查询语句，怎么样能知道表结构？

  
  解答：可以看与XML文件对应的域模型。




2.存储过程和函数的区别


  解答：1)、
从参数的返回情况来看：
如果返回多个参数值最好使用存储过程，如果只有一个返回值的话可以使用函数。

        2）、从调用情况来看：
如果在SQL语句（DML或SELECT）中调用的话一定是存储函数或存储的封装函数不可以是存储过程，但调用存储函数的时候还有好多限制以及函数的纯度等级的问题，如果是在过程化语句中调用的话，就要看你要实现什么样的功能。函数一般情况下是用来计算并返回一个计算结果而存储过程一般是用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等），所以虽然他们的语法上很相似但用户在使用他们的时候所需要完成的功能大部分情况下是不同的。




3.试述数据库完整保护的主要任务和措施。


  解答：数据库的完整性保护也就是数据库中数据正确性的维护。数据库完整性包括三个内容：实体完整性规则，参照物完整性规则以及用户定义完整性规则。 前两个是有DBMS自动处理。
实体完整性规则是说针对于基表中的关键字中属性值不能为空值，是数据库完整性的基本要求，主关键字和元组的唯一性对应。
参照物完整性规则是不允许引用不存在的元组：即基表中的外关键字要么为空，要么关联基表中必存在元组。
用户定义完整性规则针对具体的数据环境由用户具体设置的规则，它反应了具体应用中的语义要求。 一个完整性规则一般由下面三部分组成:完整性约束条件设置,完整性约束条件的检查以及完整性约束条件的处理.后两部分在数据库中一般有相应的模块处理。另外触发器也可以做完整性的保护，但触发器大量用于主动性领域。


JAVA面试之进阶知识

 
struts2中拦截器与过滤器的区别 
 拦截器是基于java反射机制的，而过滤器是基于函数回调的。
 拦截器不依赖与servlet容器，过滤器依赖与servlet容器
 拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。
 拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。
 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次

 

Oracle中导入文本数据的方法 
使用sqlldr
导入导出工具：impdp、expdp

 


2.hibernate和ibatis的优劣

JDBC：SQL语句自己写，开发效率最低，但是使用最灵活，一般被大型项目所采用。
Hibernate：SQL语句都被封装，开发效率高，但是使用不灵活，一般被小型项目采用。
iBatis：介于两者之间，应用也比较广泛。

3.hibernate的一级缓存与二级缓存


4.struts1与struts2的区别

 在软件设计上Struts2没有像struts1那样跟ServletAPI和strutsAPI有着紧密的耦合，Struts2的应用可以不依赖于ServletAPI和strutsAPI。 Struts2的这种设计属于无侵入式设计，而Struts1却属于侵入式设计。
 Struts2提供了拦截器，利用拦截器可以进行AOP编程，实现如权限拦截等功能。
 Struts2提供了类型转换器，我们可以把特殊的请求参数转换成需要的类型。在Struts1中，如果我们要实现同样的功能，就必须向Struts1的底层实现BeanUtil注册类型转换器才行。
 Struts2提供支持多种表现层技术，如JSP、freeMarker、Velocity等。
 Struts2的输入校验可以对指定方法进行校验，解决了Struts1的长久之痛。
 提供了全局范围、包范围和Action范围的国际化资源文件管理实现

Struts1 要求 Action 类继承一个抽象基类. Struts1 的一个普遍的问题是使用抽象类编程而不是接口
 Struts2 Action 类可以实现一个 Action 接口,也可实现其他的接口,使可选和定制的服务称为可能.
Struts2 提供了一个 ActionSupport 基类去实现常用的接口; Action接口不是必须的,任何有 execute 标识的POJO
对象都可以用作 Struts2 的 Action 对象

Struts1 Action 是单例的模式并且必须是线程安全的,因为仅有 Action 的一个实例来处理所有的请求.单例的策略限制了
Struts1 Action 能做的事情,并且要在开发的时候特别的小心. Action 资源必须是线程安全或者同步的
Struts2 Action 对象为每一个请求产生一个实例,因此没有线程安全的问题

Struts1 Action 依赖于 Servlet API,因为当一个Action被调用 HttpServletRequest 和 HttpServletResponse 被传递给 execute() 方法
Struts2 Action 不依赖于容器,允许 Action 脱离容器单独的被测试.如果需要的话 Struts2 Action 仍然可以访问初始的 request 和 response
但是,其他的元素减少或者消除了直接访问 HttpServletRequest 和 HttpServletResponse 的必要性

5.sql的优化

6.MQ消息的发送与接收，异常的处理

7.tomcat启动时加载的内容

编程
1.List<String>排序

  List<String> list = new ArrayList<String>();
  list.add("abcd");
  list.add("bcd");
  list.add("d");
  list.add("efgh");
  list.add("afgh");
  list.add("a");
  
  Collections.sort(list, new Comparator(){

   @Override
   public int compare(Object o1, Object o2) {
    if (!(o1 instanceof String) || !(o2 instanceof String))
    {
     throw new IllegalArgumentException();
    }
    
    return ((String)o1).length() > ((String)o2).length()? 1 :(((String)o1).length() == ((String)o2).length()?0:-1);
   }});
  
  for(String str : list)
  {
   System.out.println(str);
  }

2.单例模式的写法

3.数组排序

 

 

备用：


3.ArrayList与Set基础实现方式
4.ajax的作用，json
5.xml的用途
6.软件开发的流程
7.软件工程中的各类图及其作用
8.EntrySet的使用

  Map<String,String> map = new HashMap<String,String>();
  
  for(Map.Entry<String,String> entry : map.entrySet())
  {
   System.out.print(entry.getKey() + "  " + entry.getValue());
  }
-------------------------------------------------------------------------------------
（一） JAVA复试的问题整理
 
1 　Hibernate 的优化和返程是如何实现的，流程是怎么样？
1.尽量使用many-to-one，避免使用单项one-to-many
 2.灵活使用单向one-to-many
 3.不用一对一，使用多对一代替一对一
 4.配置对象缓存，不使用集合缓存
 5.一对多使用Bag 多对一使用Set
 6.继承使用显示多态  HQL:from object  polymorphism="exlicit" 避免查处所有对象
 7.消除大表，使用二级缓存
 
2    Struts1与Struts2的区别？
  在Action 实现类方面的对比：Struts 1 要求Action 类继承一个抽象基类；Struts 1 的 一个具体问题是使用抽象类编程而不是接口。Struts 2 Action 类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts2 提供一ActionSupport  基类去实现常用的接口。即使 Action  接口不是必须实现的，只有一个包含execute 方法的POJO 类都可以用作 Struts 2 的Action 。 
线程模式方面的对比：Struts 1 Action 是单例模式并且必须是线程安全的，因为仅有Action 的一个实例来处理所有的请求。单例策略限制了Struts 1 Action 能做的事，并且要在开发时特别小心。Action 资源必须是线程安全的或同步的；Struts 2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。 
Servlet 依赖方面的对比：Struts 1 Action 依赖于 Servlet API，因为Struts 1 Action 的execute 方法中有HttpServletRequest 和HttpServletResponse 方法。Struts 2 Action 不再依赖于 Servlet API，从而允许Action 脱离Web 容器运行，从而降低了测试Action 的难度。当然，如果Action 需要直接访问HttpServletRequest 和HttpServletResponse 参数，Struts 2 Action 仍然可以访问它们。但是，大部分时候，Action 都无需直接访问HttpServetRequest 和HttpServletResponse，从而给开发者更多灵活的选择。 
 可测性方面的对比：测试Struts 1 Action 的一个主要问题是execute 方法依赖于Servlet API，这使得Action 的测试要依赖于Web 容器。为了脱离Web 容器测试 Struts1 的Action，必须借助于第三方扩展：Struts TestCase，该扩展下包含了系列的Mock 对象(模拟了HttpServetRequest 和HttpServletResponse 对象），从而可以脱离Web 容器测 试Struts 1 的Action 类。Struts 2 Action 可以通过初始化、设置属性、调用方法来测试。 
 封装请求参数的对比：Struts 1 使用ActionForm 对象封装用户的请求参数，所有的 ActionForm 必须继承一个基类：ActionForm。普通的JavaBean 不能用作ActionForm，因此，开发者必须创建大量的ActionForm 类封装用户请求参数。虽然 Struts 1 提供了动态 ActionForm来简化 ActionForm的开发，但依然需要在配置文件中定义ActionForm；Struts2 直接使用Action 属性来封装用户请求属性，避免了开发者需要大量开发 ActionForm 类的烦琐，实际上，这些属性还可以是包含子属性的 Ric对象类型。如果开发者依然怀念 Struts 1  ActionForm 的模式，Struts2 提供ModelDriven 模式，可以让开发者使用单独的Model 对象来封装用户请求参数，但该Model 对象无需继承任何 Struts 2 基类，是一个POJO，从而降低了代码污染。 
 表达式语言方面的对比：Struts1 整合了 JSTL，因此可以使用JSTL 表达式语言。这种表达式语言有基本对象图遍历，但在对集合和索引属性的支持上则功能不强；Struts 2 可以使用JSTL，但它整合了一种更强大和灵活的表达式语言：OGNL（Object Graph Notation Language），因此，Struts 2 下的表达式语言功能更加强大。绑定值到视图的对比：Struts1 使用标准JSP 机制把对象绑定到视图页面；Struts2 使用“ValueStack ”技术，使标签库能够访问值，而不需要把对象和视图页面绑定在一起。 
 类型转换的对比：Struts1  ActionForm  属性通常都是 String  类型。Struts 1 使用commons-Beanutils 进行类型转换，每个类一个转换器，转换器是不可配置的；Struts 2 使用OGNL 进行类型转换，支持基本数据类型和常用对象之间的转换。 
 数据校验的对比：Struts1 支持在 ActionForm 重写validate 方法中手动校验，或者通过整合 Commons-validator 框架来完成数据校验。Struts 2 支持通过重写validate方法进行校验，也支持整合XWork 校验框架进行校验。 
 Action 执行控制的对比：Struts 1 支持每一个模块对应一个请求处理（即生命周期的概念），但是模块中的所有Action 必须共享相同的生命周期。Struts 2 支持通过拦截器堆栈（Interceptor    Stacks）为每一个Action 创建不同的生命周期。开发者可以根据需要创建相应堆栈，从而和不同的Action 一起使用。

3    Struts1的原理
  1.初始化：struts框架的总控制器ActionServlet是一个Servlet，它在web.xml中配置成自动启动的Servlet，在启动时总控制器会读取配置文件(struts-config.xml)的配置信息，为struts不同的模块初始化相应的对象。(面向对象思想)
   2.发送请求：用户提交表单或通过URL向WEB服务器提交请求，请求的数据用HTTP协议传给web服务器。
   3.form填充：struts的总控制器ActionServlet在用户提交请求时将数据放到对应的form对象中的成员变量中。
   4.派发请求：控制器根据配置信息对象ActionConfig将请求派发到具体的Action，对应的formBean一并传给这个Action中的excute()方法。
   5.处理业务：Action一般只包含一个excute()方法，它负责执行相应的业务逻辑(调用其它的业务模块)完毕后返回一个ActionForward对象。服务器通过ActionForward对象进行转发工作。
   6.返回响应：Action将业务处理的不同结果返回一个目标响应对象给总控制器。
   7.查找响应：总控制器根据Action处理业务返回的目标响应对象，找到对应的资源对象，一般情况下为jsp页面。
   8.响应用户：目标响应对象将结果传递给资源对象，将结果展现给用户。

4    IO的流程如何实现
 
1，根据输入源不同，构造不同的输入流
2，根据不同的需要，包装原始的输入流。比如用BufferdInputStream提高性能。
3，根据输出源不同，构造不同的输出流。
4，根据不同的需要，包装原始的输入流。
5，从输入流中读取数据写入输出流中。
6，关闭输出，输入流
 
5    WEB开发安全的注意要点
1．登陆验证码。
利用一个servlet随机产生一个验证码，由于验证码是机器随机产生的，因此暴力破解程序无法预料到具体是什么，所以可以防止暴力破解。
2．登陆身份验证。系统的每个功能都必须经过身份验证后才能访问，没有认证的请求会被过滤掉，这是最基本的安全要求：
1，所有功能都通过Struts的Action来进行访问，不直接以jsp的形式向用户提供功能访问，这样一方面可以防止向用户暴露程序的资源名称，另一方面也可更方便的进行权限控制。
2，对Struts的Actionservlet设置filter，利用该filter来检查用户的权限，这样既可以防止用户登陆后跨url访问。
3．防 止扰过权限认证的直接资源访问。虽然前面的设计中，已经要求所有的功能都通过struts的Action来进行访问，但是还是不能排除恶意用户可能会知道 程序资源名称（jsp文件），如果这类用户直接输入jsp文件的url访问，有可能会对系统形成威胁。因此需要禁止所有用户发起的直接资源访问。通常以这 种方式来实现：在Web应用中创建一个从不使用的角色：NeverUsedRole，将所有的jsp资源文件配置为必须具有NeverUserRole才 能访问。由于根本没有任何用户可以成为该角色。由于根本没有任何用户可以成为该角色，所以也就无法对该角色对应的资源直接访问。

 
6   常用的集合的区别
Collection接口 
　　Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素 （Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。 
List接口 
　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。 
LinkedList类 
　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 
　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。
 ArrayList类 
　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。 当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 
Vector类 
　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个 Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。 
Stack 类 
　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push 和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空 栈。 
et接口 
　　Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。 
Map接口 
　　请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能 映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。

Hashtable类 
　　Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。 Hashtable是同步的。

HashMap类　　 
 HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。


7   sql的优化
1）Shared pool的优化应该放在优先考虑，因为一个cache miss在shared pool中发生比在data buffer中发生导致的成本更高
2）尽可能避免排序；尽可能在内存中排序；分配合适的临时空间以减少空间分配调用。
3）建立Indexes，但索引的层次越多，效率越低，索引所包含的字段不超过4个。
4）表分区
5）使用where过滤行
   Select id from dual where id = 1

6）使用表连接而不是多个查询
   使用：
Select a.id,a.name,b.app_name from A a,B b where a.id=b.id
   而不是：
   Select a.id,a.name,b.app_name from B b where a.id=b.id from A a

7）执行连接时使用完全限定的列引用
    
8）使用CASE表达式而不是多个查询
9）使用WHERE而不用HAVING
   避免使用HAVING子句， HAVING 只会在检索出所有记录之后才对结果集进行过滤。 这个处理需要排序，总计等操作。 如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销。
10）使用exists而不用IN
11）使用相同的SQL，使用的SQL 必须绝对相同
a)所有字符必须相同
b)大小写要相同
c)空格要相同
12）WHERE子句中的连接顺序
     ORACLE采用自下而上的顺序解析WHERE子句，根据这个原理，表之间的连接必须写在其他WHERE条件之前， 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。
13）SELECT子句中避免使用 ‘ * ’
    例如：person表包含4个字段(id,name,age,address)
         Select id,name,age,address from person;
          不用：select * from person
14） 使用DECODE函数来减少处理时间
    使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表。
15） 减少对表的查询
在含有子查询的SQL语句中，要特别注意减少对表的查询。
16) 使用表的别名(Alias)
17) 用EXISTS替代IN
　　  在许多基于基础表的查询中，为了满足一个条件，往往需要对另一个表进行联接。在
这种情况下， 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。

 
8   DWR是怎么实现
它先在web.xml中配置一个Servlet，映射到特定的路径（通常是%CONTEXT_PATH%/dwr/*）。这个Servlet的作用就是初 始化要暴露给Javascript调用的Java类（通过dwr.xml进行配置），并生成相应的代理的Javascript类代码。在XHR请求到来的 时候，Servlet负责将请求的参数变成对应的Java对象，并以其为参数调用目标Java方法，并将返回值转化为Javascript代码。
 
9   list和vector的区别
List接口 
　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。 
LinkedList类 
　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 
　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。
 ArrayList类 
　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。 当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 
Vector类 
　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个 Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。 
Stack 类 
　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push 和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空 栈。

10 hashmap和hashtable的区别
Hashtable类 
　　Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。 Hashtable是同步的。

HashMap类　　 
 HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。

------------------------------------------------------------------
SSH篇（后台）
一、SSH概述
1.1 SSH的含义
    当前J2EE企业级应用分为三层：表现层-业务层-数据源层，而SSH代表了每一层的具体实现，它是三种流行的开源框架的缩写，S-Struts,S-Spring,H-Hibernate。这三者的组合是当前J2EE开发的标准模式，也代表了J2EE正在朝着简化复杂性，轻量化方向发展，最新J2EE 6已证明了这种趋势。
1.2 J2EE开发模式的演变
J2EE应用一直采用三层加构，即表现层-业务层-数据源层。
旧石器时代：J2EE应用采用表现层-远程EJB-实体EJB（或JDBC），这是最为正宗也是最复杂的J2EE开发，适用于银行等小部分项目；随后由于微软.NET的兴起以及其对J2EE的挑战，正宗的J2EE出现了一个变种：表现层-本地EJB-Ibatis，在这种模型中业务层选择了本地EJB，同时数据源层也改为Ibatis，这种模式极大的提高性能，华为大部分项目采用这种构架。在这两种架构中，由于采用了EJB组件模型，从而依赖于EJB容器，而EJB容器以一种全无或全有的方式提供服务，同时业务实现也受制于容器。这种开发模式导致了以下复杂性：依赖于应用服务器，不可移植，开发困难，无法在容器外测试，部署复杂，效率低下。
新石器时代：在新石器时代依然采用了三层加构，只是抛弃了EJB，而采用了Spring等轻量级容器，同时持久化由全自动的Hibernate承担。在这种架构中，由于放弃了EJB，放弃了全功能的应用服务器，在节省了软件许可费用的同时也大大提高了软件开发效率。由于web服务器的可移植也好于应用服务器，从而使得J2EE应用可顺利移植。

1.3 SSH与传统开发的比较
    从上面所述可以看出传统J2EE开发和SSH开发的不同。简言之，传统J2EE开发采用EJB组件在限制了业务实现的同时也极其复杂，只适用银行等一部分应用；SSH不强制采用应用服务器，不限制业务实现，透明的持久化从而减化了开发的复杂度，提高了开发效率。
二 、Struts-WEB层开发的标准
2.1 Struts简介
    Struts是Apache软件基金会的一个开源项目。采用Servlet／JSP技术，实现了基于J2EE Web应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。使用标准的JSP以外，还提供了大量的标签库使用，同时也可以与其他表现层组件技术（产品）进行整合。Struts出现之前J2EE Web层没有统一标准，各个公司都是自有框架，给从业者，企业带来了诸多不便。Struts采用了经典MVC设计，从而事实上成为WEB层开发的标准
2.2 Struts的原理
     在谈到Struts前，简单讲下MVC设计模式。MVC即Model-View-Controller的缩写，MVC减弱了业务逻辑接口和数据接口之间的耦合，同时让视图层更富于变化。
 MVC的工作原理,如下图1所示：
 
控制器（Controller）-负责转发请求，对请求进行处理。
视图（View） - 界面设计人员进行图形界面设计。
模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。
Struts 是MVC的一种实现，它将 Servlet和 JSP 标记用作实现的一部分。Struts继承了MVC的各项特性，并根据J2EE的特点，做了相应的变化与扩展。Struts的体系结构与工作原理如下图2所示：
 
从图2中我们可以知道，Struts的体系结构包括模型（Model），视图（View）和控制器（Controller）三部分。
下面让我们从用户发出请示角度来看看struts的体系结构（Model 2）与工作原理：
（1）首先，用户（通常通过浏览器，如IE）发出请求，Struts的控制器（Controller Servlet）得到请求。
（2）Struts控制器通过配置文件得到业务逻辑处理Action，并调用Action的处理用户请求。
（3）Action处理业务业务逻辑（可能查找数据库或调用别的系统），处理完成后，填充相关的Model对象，并把控制权返回控制器。
（4）控制器选择相应的视图（视图从模型里取出数据），并返回给用户。
2.3 Struts2简介
Struts2提供了对MVC的一个清晰的实现，这一实现包含了很多参与对所以请求进行处理的关键组件，如：拦截器、OGNL表达式语言、堆栈。下图是Struts2的处理流程。
 
一个请求在Struts2框架中的处理大概分为以下几个步骤 
1 客户端初始化一个指向Servlet容器（例如Tomcat）的请求 
2 这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin） 
3 接着FilterDispatcher被调用，FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action 
4 如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy 
5 ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类 
6 ActionProxy创建一个ActionInvocation的实例。 
7 ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 
8 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到ActionMapper
2.4 Struts，Struts2的比较
在Action 实现类方面的对比：Struts 1 要求Action 类继承一个抽象基类；Struts 1 的 一个具体问题是使用抽象类编程而不是接口。Struts 2 Action 类可以实现一个Action接口，也可以实现其他接口，使可选和定制的服务成为可能。Struts2 提供一ActionSupport  基类去实现常用的接口。即使 Action  接口不是必须实现的，只有一个包含execute 方法的POJO 类都可以用作 Struts 2 的Action 。

线程模式方面的对比：Struts 1 Action 是单例模式并且必须是线程安全的，因为仅有Action 的一个实例来处理所有的请求。单例策略限制了Struts 1 Action 能做的事，并且要在开发时特别小心。Action 资源必须是线程安全的或同步的；Struts 2 Action对象为每一个请求产生一个实例，因此没有线程安全问题。

Servlet 依赖方面的对比：Struts 1 Action 依赖于 Servlet API，因为Struts 1 Action 的execute 方法中有HttpServletRequest 和HttpServletResponse 方法。Struts 2 Action 不再依赖于 Servlet API，从而允许Action 脱离Web 容器运行，从而降低了测试Action 的难度。当然，如果Action 需要直接访问HttpServletRequest 和HttpServletResponse 参数，Struts 2 Action 仍然可以访问它们。但是，大部分时候，Action 都无需直接访问HttpServetRequest 和HttpServletResponse，从而给开发者更多灵活的选择。

可测性方面的对比：测试Struts 1 Action 的一个主要问题是execute 方法依赖于Servlet API，这使得Action 的测试要依赖于Web 容器。为了脱离Web 容器测试 Struts1 的Action，必须借助于第三方扩展：Struts TestCase，该扩展下包含了系列的Mock 对象(模拟了HttpServetRequest 和HttpServletResponse 对象），从而可以脱离Web 容器测 试Struts 1 的Action 类。Struts 2 Action 可以通过初始化、设置属性、调用方法来测试。

封装请求参数的对比：Struts 1 使用ActionForm 对象封装用户的请求参数，所有的 ActionForm 必须继承一个基类：ActionForm。普通的JavaBean 不能用作ActionForm，因此，开发者必须创建大量的ActionForm 类封装用户请求参数。虽然 Struts 1 提供了动态 ActionForm来简化 ActionForm的开发，但依然需要在配置文件中定义ActionForm；Struts2 直接使用Action 属性来封装用户请求属性，避免了开发者需要大量开发 ActionForm 类的烦琐，实际上，这些属性还可以是包含子属性的 Ric对象类型。如果开发者依然怀念 Struts 1  ActionForm 的模式，Struts2 提供ModelDriven 模式，可以让开发者使用单独的Model 对象来封装用户请求参数，但该Model 对象无需继承任何 Struts 2 基类，是一个POJO，从而降低了代码污染。

表达式语言方面的对比：Struts1 整合了 JSTL，因此可以使用JSTL 表达式语言。这种表达式语言有基本对象图遍历，但在对集合和索引属性的支持上则功能不强；Struts 2 可以使用JSTL，但它整合了一种更强大和灵活的表达式语言：OGNL（Object Graph Notation Language），因此，Struts 2 下的表达式语言功能更加强大。绑定值到视图的对比：Struts1 使用标准JSP 机制把对象绑定到视图页面；Struts2 使用“ValueStack ”技术，使标签库能够访问值，而不需要把对象和视图页面绑定在一起。

类型转换的对比：Struts1  ActionForm  属性通常都是 String  类型。Struts 1 使用commons-Beanutils 进行类型转换，每个类一个转换器，转换器是不可配置的；Struts 2 使用OGNL 进行类型转换，支持基本数据类型和常用对象之间的转换。

数据校验的对比：Struts1 支持在 ActionForm 重写validate 方法中手动校验，或者通过整合 Commons-validator 框架来完成数据校验。Struts 2 支持通过重写validate方法进行校验，也支持整合XWork 校验框架进行校验。

Action 执行控制的对比：Struts 1 支持每一个模块对应一个请求处理（即生命周期的概念），但是模块中的所有Action 必须共享相同的生命周期。Struts 2 支持通过拦截器堆栈（Interceptor    Stacks）为每一个Action 创建不同的生命周期。开发者可以根据需要创建相应堆栈，从而和不同的Action 一起使用。经过上面简要介绍，不难发现，Struts 2 确实在 Struts 1 上做出了巨大的改进，的确是一个非常具有实用价值的MVC 框架。

三、 Spring-轻量级容器
3.1 Spring简介
   Spring是新一代的J2EE框架，核心在于对受其管理的对象提供所需服务，而不要求对象做出任何改变，具体包括：注入协作对象或依赖对象，声明性事务，同现有大量框架的无缝集成。

3.2 Spring的原理
   Spring核心可用两句话概括：自动注入某一对象或组件所需要的服务而不用修改对象；通过AOP为POJO对象提供声明性的企业级服务。

3.3 Spring与EJB容器
   Spring容器与EJB容器一样提供了大量企业级服务，但不要求受管理的对象知道容器的存在，即对象不需要实现Spring特有的东西。与些同时，Spring提供的服务是可选择的，即可以使用也可以不使用。
EJB容器是一种重量级容器，要么接受其提供的所有服务（即使不用），要么任何服务都不接受，并且求受其管理的对象要实现EJB特有的东西，从而干扰了业务实现。

3.4 Spring在开发中的应用
   Spring有完整的Web层MVC，同时提供了Hibernate，Ibatis的集成。由于Struts是事实上Web层开发的标准，尽管Spring MVC更先进，开发效率更高，现阶段Spring在开发中提供

SPRING 七大模块图：
 


四、 Hibernate-持久化的标准
4.1 Hibernate简介
  Hibernate是一种Java语言下的对象关系映射解决方案。它的设计目标是在JDBC之上提供一层薄薄的封装，同时提供完善的透明的持久化；为应用程序增加O/R映射，但又不脱离底层的关系数据库。

4.2 Hibernate原理和功能
   Hibernate采用CGLIB以动态字节码生成的方式为持久化对象创建运行时代理，执行变更侦测来提供透明的持久化，动态的在POJO（老式JAVA对象），PO（持久化对象）之间自动转换。新建的POJO或托管POJO调用Session对象保存后自动成为PO，而PO与Session脱离干系之后又变成托管POJO，可以充当数据传输对象而不用再额外的对象。同时Hibernate提供了延迟加载与缓存功能提供更好的性能。
4.3 Hibernate的缓存机制
   Hibernate支持两级缓存，一级Session内缓存，不可选，强制使用；二级进程间或集群间，可选的。一级Session缓存主要提供在同一个事务内部的缓存，保持事物唯一性（确保事务内两次加载数据库同一行时，返回的对象为同一个内存对象），不存在并发访问。二级缓存可以为进程间或集群间，二级缓存需要提供并发访问机制（数据库同一行在内存对应不同的JAVA对象），二级缓存可以把JAVA对象缓存到内存中，虚拟内存，磁盘上等。
4.4 Hibernate，Ibatis的比较
   相对Hibernate "一站式"ORM解决方案而言，ibatis 是一种"半自动化"的ORM实现，仅提供SQL映射，SQL参数输入输出绑定到POJO上，而把SQL语句定义留给开发人员。Ibatis提供了缓存查询结果，缓存策略也是可插拔的。Hibernate对数据库结构提供了较为完整的封装，Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL 的自动生成和执行。程序员往往只需定义好了POJO 到数据库表的映射关系，即可通过Hibernate 提供的方法完成持久层操作。程序员甚至不需要对SQL 的熟练掌握， Hibernate/OJB 会根据制定的存储逻辑，自动生成对应的SQL 并调用JDBC 接口加以执行。iBATIS虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。当系统属于二次开发,无法对数据库结构做到控制和修改,那iBATIS的灵活性将比Hibernate更适合。系统数据处理量巨大，性能要求极为苛刻，这往往意味着我们必须通过经过高度优化的SQL语句（或存储过程）才能达到系统性能设计指标。在这种情况下iBATIS会有更好的 可控性和表现。

4.5 Hibernate进行大数据量处理时的优化操作
1) 在处理大数据量时，会有大量的数据缓冲保存在Session的一级缓存中，这缓存大太时会严重显示性能，所以在使用Hibernate处理大数据量的，可以使用session.clear()或者session. Evict(Object) 在处理过程中，清除全部的缓存或者清除某个对象。 
2) 对大数据量查询时，慎用list()或者iterator()返回查询结果， 
1. 使用List()返回结果时，Hibernate会所有查询结果初始化为持久化对象，结果集较大时，会占用很多的处理时间。 
2. 而使用iterator()返回结果时，在每次调用iterator.next()返回对象并使用对象时，Hibernate才调用查询将对应的对象初始化，对于大数据量时，每调用一次查询都会花费较多的时间。当结果集较大，但是含有较大量相同的数据，或者结果集不是全部都会使用时，使用iterator()才有优势。 
3. 对于大数据量，使用qry.scroll()可以得到较好的处理速度以及性能。而且直接对结果集向前向后滚动。 
3) 对于关联操作，Hibernate虽然可以表达复杂的数据关系，但请慎用，使数据关系较为简单时会得到较好的效率，特别是较深层次的关联时，性能会很差。 
4) 对含有关联的PO（持久化对象）时，若default-cascade="all"或者 “save-update”，新增PO时，请注意对PO中的集合的赋值操作，因为有可能使得多执行一次update操作。 
5) 在一对多、多对一的关系中，使用延迟加载机制，会使不少的对象在使用时方会初始化，这样可使得节省内存空间以及减少数据库的负荷，而且若PO中的集合没有被使用时，就可减少互数据库的交互从而减少处理时间。 
6) 对于大数据量新增、修改、删除操作或者是对大数据量的查询，与数据库的交互次数是决定处理时间的最重要因素，减少交互的次数是提升效率的最好途径，所以在开发过程中，请将show_sql设置为true，深入了解Hibernate的处理过程，尝试不同的方式，可以使得效率提升。 
7) Hibernate是以JDBC为基础，但是Hibernate是对JDBC的优化，其中使用Hibernate的缓冲机制会使性能提升，如使用二级缓存以及查询缓存，若命中率较高明，性能会是到大幅提升。 
8) Hibernate可以通过设置hibernate.jdbc.fetch_size，hibernate.jdbc.batch_size等属性，对Hibernate进行优化。
前台篇
1.1  Ajax A原理
ajax并不是一个新生的语言，它是一系列语言的结合体：HTML/XHTML、CSS、DOM、XML、XSLT、XMLHttp、JavaScript。Ajax的工作原理如下图，由此用户可以不用为提交了Form而长时间等待服务器应答，而且通过Ajax也可以开发出华丽的Web交互页面。 
Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。
在使用Ajax时，需要创建XMLHttpRequest对象，由XMLHttpRequest对象代表用户提交数据给后台服务器，不同浏览器的创建方式略有不同。在利用Ajax向服务器提交请求时，需要先确定三点：
? 使用GET或POST方式提交请求？
? 请求的url地址和传递的参数。？
? 传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。
例如：
request = new XMLHttpRequest();
var url="http://localhost/test/ajax.do?method=list&time=" + Math.random();
request.open("GET", url, true);
request.onreadystatechange = updatePage;
request.send(null);
//更新页面
function updatePage() {
//检测返回状态，并更新页面
}
1.2  ajax的优点
1、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻
服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则
是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
1.3常用AJAX框架比较 
jQuery是一个优秀的Javascrīpt框架，其宗旨是――WRITE LESS,DO MORE,写更少的代码,做更多的事情。快速、简洁，能够很轻易地处理HTML文档、控制事件、给页面添加动画和Ajax效果。它是轻量级的js库，它兼容CSS3，还兼容各种浏览器。DWR(Direct Web Remoting)是一个WEB远程调用框架.利用这个框架可以让AJAX开发变得很简单.利用DWR可以在客户端利用JavaScript直接调用服务 端的Java方法并返回值给JavaScript就好像直接本地客户端调用一样(DWR根据Java类来动态生成JavaScrip代码)，对于不熟悉JavaScrip的开发人员也用DWR也可以开发出很好的效果。

1.4 JS，DOM
DOM是W3C标准（Document Object Model for HTML）。DOM 定义了用于 HTML 的一系列标准的对象，以及访问和处理 HTML 文档的标准方法。DOM的原理是将XML/XHTML文档装入内容，并以节点的形式解析为一棵节点树。DOM提供相应的API，可以对节点树进行增删改查，通过 DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的内容进行修改和删除，同时也可以创建新的元素。DOM能被JavaScript使用，从而动态的更新页面内容。
下面举一些用法
//查找节点:三种方式。
//1:getElementById();  --比较常用，根据id获取节点,缺陷：如果要获取一个相同的节点，每个节点都需要加上一个id。所以引发了另一种。getElementsByTagName();
//2:getElementsByTagName(); --根据标签名称获取元素。
//3:getElementByName();    --专门争对单选框和多选框。因为单选框和多选框他们的name值都是一样的。
 //var node = document.getElementById("emnode"); //获取一个元素
 //var nodeName = document.getElementsByTagName("li"); //获取整个文档中的li标签
 //var nodeName1 = node.getElementsByTagName("li"); //只获取node节点下面的li标签
 //var name = document.getElementByNmae("radioName");  //获取选中框的name属性。 用于      单选框和多选框 
//争对dom文档中的增删改查
//增加元素
//创建元素
//document.createElement("标签名称");  如：document.createElement("div");
//创建文本节点
//document.createTextNode("文本内容");
//追加到元素中。
//div.appendChild(p);  //往div标记里面追加一个p标记
//从前面进行插入元素
//p.insertBefore("插入的节点"，"放在谁都前面"); 如:p.insertBefore("p","p");
//克隆第一个节点
//p.firstChild.cloneNode();  //潜克隆(只有本身)
//p.firstChild.cloneNode(true); //深克隆(本身和他里面的元素)
//修改元素
//设置文本元素的属性
// text.setAttribute("属性值","内容"); 如:text.setAttribute("value","ok");
//  text.getAttribute("属性值"). 如：text.getAttribute("value"). 
// text.value="ok"  最常用
//删除元素
//p.parendNode.removeChild(p);   
    
 //判断是否有子节点
 //div.hasChilldNodes();
?
数据库优化篇
数据库优化：常用优化手段有
1）Shared pool的优化应该放在优先考虑，因为一个cache miss在shared pool中发生比在data buffer中发生导致的成本更高
2）尽可能避免排序；尽可能在内存中排序；分配合适的临时空间以减少空间分配调用。
3）建立Indexes，但索引的层次越多，效率越低，索引所包含的字段不超过4个。
4）表分区
例子：假设有一个CUSTOMER表，表中有数据200000行，我们将此表通过CUSTOMER_ID进行分区，每个分区存储100000行，我们将每个分区保存到单独的表空间中，这样数据文件就可以跨越多个物理磁盘。下面是创建表和分区的代码，如下：
CREATE TABLE CUSTOMER 
( 
    CUSTOMER_ID NUMBER NOT NULL PRIMARY KEY, 
    FIRST_NAME  VARCHAR2(30) NOT NULL, 
    LAST_NAME   VARCHAR2(30) NOT NULL, 
    PHONE        VARCHAR2(15) NOT NULL, 
    EMAIL        VARCHAR2(80), 
    STATUS       CHAR(1) 
) 
PARTITION BY RANGE (CUSTOMER_ID) 
( 
    PARTITION CUS_PART1 VALUES LESS THAN (100000) TABLESPACE CUS_TS01, 
    PARTITION CUS_PART2 VALUES LESS THAN (200000) TABLESPACE CUS_TS02 
)

5）使用where过滤行
   Select id from dual where id = 1

6）使用表连接而不是多个查询
   使用：
Select a.id,a.name,b.app_name from A a,B b where a.id=b.id
   而不是：
   Select a.id,a.name,b.app_name from B b where a.id=b.id from A a

7）执行连接时使用完全限定的列引用
    
8）使用CASE表达式而不是多个查询
例如：SELECT col1, col2, 
       CASE 
            WHEN col3 > 1 AND col3 <2 
             THEN '1' 
            WHEN col3 > 2 AND col3 <3 
             THEN '2' 
            WHEN col3 > 3 AND col3 <4 
             THEN '3' 
            ELSE '4' 
           END mylevel 
    FROM table1

9）使用WHERE而不用HAVING
   避免使用HAVING子句， HAVING 只会在检索出所有记录之后才对结果集进行过滤。 这个处理需要排序，总计等操作。 如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销。
   例如：
　 低效：
　　 SELECT  REGION，AVG(LOG_SIZE)
FROMLOCATION
GROUPBYREGION
HAVINGREGIONREGION!=‘SYDNEY’
ANDREGION!=‘PERTH’
　  高效：
　　　SELECT  REGION，AVG(LOG_SIZE)
FROMLOCATION
WHEREREGIONREGION!=‘SYDNEY’
ANDREGION!=‘PERTH’
GROUPBYREGION

10）使用exists而不用IN
11）使用相同的SQL，使用的SQL 必须绝对相同
a)所有字符必须相同
b)大小写要相同
c)空格要相同
   例如：
　       SELECT*FROMEMP;
　　和下列每一个都不同
　  SELECT*fromEMP;
Select*FromEmp;
SELECT*FROMEMP;
12）WHERE子句中的连接顺序
     ORACLE采用自下而上的顺序解析WHERE子句，根据这个原理，表之间的连接必须写在其他WHERE条件之前， 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。
例如：
　　（低效，执行时间156.3秒）
　　     SELECT…
FROMEMPE
WHERESAL>50000
ANDJOB=‘MANAGER’
AND25<(SELECTCOUNT(*)FROMEMP
WHEREMGR=E.EMPNO);
　　(高效,执行时间10.6秒)
　　　   SELECT…
FROMEMPE
WHERE25<(SELECTCOUNT(*)FROMEMP
WHEREMGR=E.EMPNO)
ANDSAL>50000
ANDJOB=‘MANAGER’;
13）SELECT子句中避免使用 ‘ * ’
    例如：person表包含4个字段(id,name,age,address)
         Select id,name,age,address from person;
          不用：select * from person
14） 使用DECODE函数来减少处理时间
    使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表。
　　例如：
　　       SELECT  COUNT(*)，SUM(SAL)
FROM　EMP
WHEREDEPT_NO=0020
ANDENAMELIKE　‘SMITH%’;
SELECTCOUNT(*)，SUM(SAL)
FROM　EMP
WHEREDEPT_NO=0030
ANDENAMELIKE　‘SMITH%’;
　　    你可以用DECODE函数高效地得到相同结果
　　        SELECT  COUNT(DECODE(DEPT_NO,0020,’X’,NULL))D0020_COUNT,
COUNT(DECODE(DEPT_NO,0030,’X’,NULL))D0030_COUNT,
SUM(DECODE(DEPT_NO,0020,SAL,NULL))D0020_SAL,
SUM(DECODE(DEPT_NO,0030,SAL,NULL))D0030_SAL
FROMEMPWHEREENAMELIKE‘SMITH%’;
　　  类似的，DECODE函数也可以运用于GROUP BY 和ORDER BY子句中。
15） 减少对表的查询
　　在含有子查询的SQL语句中，要特别注意减少对表的查询。
　　例如：
　　低效
　　　SELECT  TAB_NAME
FROMTABLES
WHERETAB_NAME=(SELECTTAB_NAME
FROMTAB_COLUMNS
WHEREVERSION=604)
AND　DB_VER=(SELECTDB_VER
FROMTAB_COLUMNS
WHEREVERSION=604)
　　 高效
　　　SELECT   TAB_NAME
FROMTABLES
WHERE(TAB_NAME,DB_VER)
=(SELECTTAB_NAME,DB_VER)
FROMTAB_COLUMNS
WHEREVERSION=604)
低效：
　　　  UPDATEEMP
SETEMP_CAT=(SELECTMAX(CATEGORY)FROMEMP_CATEGORIES),
SAL_RANGE=(SELECTMAX(SAL_RANGE)FROMEMP_CATEGORIES)
WHEREEMP_DEPT=0020;
　　  高效：
　 　    UPDATEEMP
SET(EMP_CAT,SAL_RANGE)
=(SELECTMAX(CATEGORY),MAX(SAL_RANGE)
FROMEMP_CATEGORIES)
WHEREEMP_DEPT=0020;
 16) 使用表的别名(Alias)
      Select p.id,p.name, a.address 
from person p,address a 
where p.id=a.person_id
 17) 用EXISTS替代IN
　　  在许多基于基础表的查询中，为了满足一个条件，往往需要对另一个表进行联接。在
这种情况下， 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。
　　低效：
　　　SELECT  *
FROMEMP(基础表)
WHEREEMPNO>0
ANDDEPTNOIN(SELECTDEPTNO
FROMDEPT
WHERELOC=‘MELB’)
　　高效：
　　　 SELECT  *
FROMEMP(基础表)
WHEREEMPNO>0
ANDEXISTS(SELECT‘X’
FROMDEPT
WHEREDEPT.DEPTNO=EMP.DEPTNO
ANDLOC=‘MELB’)

18） 用NOT EXISTS替代NOT IN
　　 在子查询中，NOT IN子句将执行一个内部的排序和合并。 无论在哪种情况下，NOT
 IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历)。 为了避免使用NOT 
IN ，我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.
　　例如：
　　 SELECT   *
FROM     EMP
WHERE   DEPT_NO  NOT IN(SELECTDEPT_NO
                              FROM  DEPT
                              WHERE  DEPT_CAT=’A’);
　　为了提高效率。改写为：
　　(高效)
　 　SELECT  *
FROM   EMP A,DEPT B
WHERE  A.DEPT_NO = B.DEPT(+)
         AND  B.DEPT_NO  IS  NULL
         AND  B.DEPT_CAT(+)=‘A’
  19) 用表连接替换EXISTS
　　通常来说，采用表连接的方式比EXISTS更有效率
　　    SELECT     E。NAME
FROM     EMP  E
WHEREE   XISTS(SELECT  ‘X’
                 FROM  DEPT
                 WHERE  DEPT_NO = E.DEPT_NO
                 ANDDEPT_CAT=‘A’);
　　(更高效)
　　　SELECT    ENAME
FROM       DEPT D,EMP  E
WHERE      E.DEPT_NO=D.DEPT_NO
AND    DEPT_CAT=‘A’;

20）用EXISTS替换DISTINCT
　　当提交一个包含一对多表信息(比如部门表和雇员表)的查询时，避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换
　　例如：
　　低效：
　　 SELECTDISTINCTDEPT_NO,DEPT_NAME
FROMDEPTD,EMPE
WHERED.DEPT_NO=E.DEPT_NO
　　 高效：
　　SELECTDEPT_NO,DEPT_NAME
FROMDEPTD
WHEREEXISTS(SELECT‘X’
FROMEMPE
WHEREE.DEPT_NO=D.DEPT_NO);
　　EXISTS 使查询更为迅速，因为RDBMS核心模块将在子查询的条件一旦满足后，立刻返回结果。
21）删除重复记录
　　最高效的删除重复记录方法 ( 因为使用了ROWID)
　 　DELETEFROMEMPE
WHEREE.ROWID>(SELECTMIN(X.ROWID)
FROMEMPX
WHEREX.EMP_NO=E.EMP_NO);
 
设计模式篇
常用的设计模式按用途可分为创建型，结构型，行为型等三类。创建型模式与对象的创建有关，结构型模式处理类或对象的组合，行为型模式对类或对象怎么样交互和分配职责进行处理。其中，创建型模式包括：工厂方法，抽象工厂，单例，原型等；结构型模式：适配器，装饰器，代理等；行为型：命令，模板方法，迭代器，职责连，访问器等。
常用J2EE设计模式，按表现层-业务层-数据源层可作如下分类。表现层：控制过滤器，前端控制器，应用控制器，视图助手；业务层模式：业务代表，服务定位器，会话门面，传输对象等，这些都是比较常用的，华为的框架多用这些，要记清。数据源层：数据访问对象，服务激发器，数据映射器等。

常用的设计模式列举：

1.1：工厂模式：
   工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A(). 工厂模式也是用来创建实例对象的，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。
例如：
         (1). public interface Mobile{
　　               public void call();
　　            }

          (2). public class Nokia implements Mobile{
　　               public void call(){
　　               System.out.println("Nokia produced ...");
　　               }
　　            } 
                   public class Motorola implements Mobile{
　                 public void call(){
　　               System.out.println("Motorola produced ...");
　　               }
　　            }
(3). public class SimbleFactory
             {
　　             public Mobile createMobile(String mobileName){
　　             if(mobileName.equals("NOKIA")){
　　             new Nokia();
　　            }else if(mobileName.equals("MOTOROLA")){
　　                new Motorola();
　　            }else{
　　                throw new Exception("还不支持该种类型的手机生产！");
　　            }
　　          }
　　        } 
 
1.2：单例模式：
   单例模式确保一个类只有一个实例，自行提供这个实例并向整个系统提供这个实例。 
   特点：1）一个类只能有一个实例  2）自己创建这个实例  3）整个系统都要使用这个实例 
       public class Singleton    
{    
    private static final Singleton singleton = new Singleton();
   
    private Singleton()    
    {    
    }    
    public static Singleton getInstance()    
    {    
        return singleton;    
    }    
} 

1.3：代理模式：
   代理模式（Proxy Pattern）, 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不 想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

例如：4个java类来描述说明Proxy设计模式实现方式；
 ProxySubject.java  代理类；ISubject.java      RealSubject接口
 RealSubject.java  RealSubject；ProxyTest.java     带有main方法的测试类
1、 ProxySubject.java
package proxy;
public class ProxySubject implements ISubject {
  private ISubject subject;
  private ProxySubject() {
  }
  public ProxySubject(ISubject subject) {
    if (subject == null)
      subject = new RealSubject();
    this.subject = subject;
  }
  public void request() {
    preRequest();
    this.subject.request();
    postRequest();
  }
  private void preRequest() {
    System.out.println("pre request.");
  }
  private void postRequest() {
    System.out.println("post request.");
  }
}