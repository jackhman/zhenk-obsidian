Java默认情况是根据内存地址来区分不同的对象，关系数据库则是根据主键值区分不同的行。hibernate使用对象标识符（OID）来建立对象和数据库表中记录的关联桥梁，OID和数据库记录的主键相对应。为了保证OID的唯一性和不可变性，应让Hibernate产生OID值，而不是应用程序。


分布式架构，大容量、高性能的分布式服务器系统开发原理

TCP/IP协议编程

网络编程

设计模式

复杂SQL语句、存储过程

RESTful通讯架构（网络通讯）

Spring

     ClassPathXmlApplicationContext实现了接口ApplicationContext；接口ApplicationContext继承了BeanFactory的接口
ApplicationContext可以使用的方法更多，所以一般用ApplicationContext

   控制反转：把具体的实现反转到了抽象的接口概念上；依赖注入：面向的是接口，注入它的实现

   setter注入和构造方法注入，当有多个参数时可以定义索引或类型；可以把简单属性的值放在配置文件中，这很少用

   事务管理：就是对一系列的动作进行封装

一、Hibernate


主键映射：自然主键与代理主键
         1）自然主键：充当主键的字段本身具有一定的含义，是构成记录的组成部分
         2）代理主键：充当主键的字段本身不具有业务含义，只起到主键的作用，比如自动增长类型的ID号等。




Hibernate延迟加载(从数据库中得到)实现： a）实体对象  b）集合  c）属性
                 实现方式：session.get()和session.load()

延迟加载（懒加载）：只有真正使用该对象时，才会创建，对于hibernate而言，真正使用的时候才会发出sql语句。（在查询对象时不会发送sql语句，只有需要使用该对象时才会发送）


一）、load加载方式：load来加载数据库中的对象，此时是不会执行sql语句，而是得到的这个对象其实是一个代理对象（只保存了实体对象的id值），当要使用这个代理对象(当 Hibernate 延迟加载关联实体时，将会采用 Javassist 生成一个动态代理对象Person_$$_javassist_0 类的实例，这个代理对象将负责代理“暂未加载”的关联实体。)，得到其他属性，这时才会发出sql语句(应用程序需要使用“暂未加载”的关联实体，Person_$$_javassist_0 代理对象会负责去加载真正的关联实体，并返回实际的关联实体――这就是最典型的代理模式。)
二）、get加载方式：加载对象的时候，不管使不使用，都会发出sql语句，从数据库中查询。


代理模式:1)一种应用非常广泛的设计模式，当客户端代码需要调用某个对象时，客户端实际上也不关心是否准确得到该对象，它只要一个能提供该功能的对象即可，此 时我们就可返回该对象的代理（Proxy）。
         2)在这种设计方式下，系统会为某个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个 Java 对象代表另一个 Java 对象来采取行动。在某些情况下，客户端代码不想或不能够直接调用被调用者，代理对象可以在客户和目标对象之间起到中介的作用。
         3)对客户端而言，它不能分辨出代理对象与真实对象的区别，它也无须分辨代理对象和真实对象的区别。客户端代码并不知道真正的被代理对象，客户端代码面向接口编程，它仅仅持有一个被代理对象的接口。
         4)总而言之，只要客户端代码不能或不想直接访问被调用对象――这种情况有很多原因，比如需要创建一个系统开销很大的对象，或者被调用对象在远程主机上，或者目标对象的功能还不足以满足需求……，而是额外创建一个代理对象返回给客户端使用，那么这种设计方式就是代理模式。

缓存机制：1）一级缓存――session ，当session关闭的时候（缓存销毁了），查询对象的时候就要再次发送sql语句进行查询数据，将对象查询出来，放到session的一级缓存中去；  
          2）二级缓存――sessionfactory：当session关闭的时候，一级缓存就会不存在，再发sql――这时来配置二级缓存。

1.  一级缓存的管理:

evit(Object obj)  将指定的持久化对象从一级缓存中清除,释放对象所占用的内存资源,指定对象从持久化状态变为脱管状态,从而成为游离对象。

clear()  将一级缓存中的所有持久化对象清除,释放其占用的内存资源。

contains(Object obj) 判断指定的对象是否存在于一级缓存中。

flush() 刷新一级缓存区的内容,使之与数据库数据保持同步。

2.一级缓存应用： save()。当session对象调用save()方法保存一个对象后，该对象会被放入到session的缓存中。 get()和load()。当session对象调用get()或load()方法从数据库取出一个对象后，该对象也会被放入到session的缓存中。 使用HQL和QBC等从数据库中查询数据。

3.二级缓存的管理：

evict(Class arg0, Serializable arg1)将某个类的指定ID的持久化对象从二级缓存中清除,释放对象所占用的资源。

sessionFactory.evict(Customer.class, new Integer(1));  
evict(Class arg0)  将指定类的所有持久化对象从二级缓存中清除,释放其占用的内存资源。

sessionFactory.evict(Customer.class);  
evictCollection(String arg0)  将指定类的所有持久化对象的指定集合从二级缓存中清除,释放其占用的内存资源。

sessionFactory.evictCollection("Customer.orders");  

ThreadLocal模式 (线程局部变量模式) :来维护和管理Session对象，避免多个线程在同一个Session实例上操作时，可以为每个

   Spring 
不用实例化类，由容器中的beanFactory直接创建，隐藏了创建的细节。不用关心类（javaBean）之间的依赖关系，由容器来进行负责。通过
    事务管理：
    AOP:面向方面编程，定义从左到右（横切）的关系，水平散布在所有对象层次
    OOP:面向对象编程，引入封装、继承、多态等建立对象层次结构，用以模拟公共行为的一个集合，允许定义从上到下的关系