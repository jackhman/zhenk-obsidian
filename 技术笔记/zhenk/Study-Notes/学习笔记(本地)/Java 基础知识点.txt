http://www.laixuexi.cc/soft/java ---下载视频

http://www.lthack.com/ ---Baodongmei1234567890

http://bbs.51cto.com/thread-1491690-1.html-----黑马Java全套教程【持续分享中】

*标志符的规则：只能是字母，数字，下划线，$;
               不能以数字开头，最好是字母开头;严格区分大小写；
               不能使用关键字作为标志符


public static void main(String[] args){
     //方法体     
}

//1.main()是一个方法，是主方法，为程序的入口
//2.权限修饰符：public protected 缺省 private ---面向对象的封装性
//3.对于方法来讲：static final abstract 关键字
//4.方法的返回值：void /  具体的返回值类型（基本的数据类型 & 引用数据类型），方法内部一定要有return
//5.方法名：命名的规则：xxxYyyZzz。给方法命名时，要见名之意
//6.形参列表：同一个方法名不同的形参列表的诸多个方法间构成重载。   形参 & 实参---方法的参数传递机制：值传递
//7.方法体：方法定义的是一种功能，具体的实现由方法体操作。




static 静态(全局)关键字，可以用来属性(类变量)、方法(类方法)、代码块、内部类---表示在一个类中所有对象所共享,随着类的加载而加载。要用类来调用静态方法和静态变量，所以没有多态性。

     static修饰属性(类变量)和实例变量(非static修饰的属性)的区别：类变量是在一个类中所有对象所共享的，而实例变量是各有自己的内存地址。类变量方便在没有创建对象的情况下来进行调用(方法/变量)，在类加载的时候类变量就加载。---可以通过类进行调用也可以通过对象来调用。


abstract：1）抽象类(就是静态类)，只能用来被继承（不能多重继承），可以声明抽象方法或者普通方法（），不能实例化，也不能用new来实例化抽象类，即不能用抽象类来创建对象。
          声明不定义（实现）。然后由子类继承并实现抽象类。
          2）抽象方法（只有方法的声明，没有方法体（实现））必须被子类实现。
          3）含有抽象方法的类必须被声明为抽象类，抽象类必须被继承，抽象方法必须被重写。类的组成成分：属性和方法（通过方法获取属性-调用属性）


抽象类(父类)中的抽象方法没被全部继承，说明子类中有一个隐藏的抽象方法，所以这个子类一定是抽象类(子类)


模板方法设计模式：抽象类(父类)中的抽象方法(一定要在子类中实现)被此类(父类)中的实体方法(不需要在父类中进行重写)调用


静态方法可以继承接口，并实现接口中的方法

         
接口：类实现多个接口（implements），只有声明抽象方法(public abstract void XX();)和常量（“成员变量”--没写时默认为public static final），没有实现类（new本类，却可以new子类对象）
   实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现所以方法。
      修饰符：public, abstract, default, static and strictfp
      接口之间可以多接口继承extends。类与接口之间可以多接口实现implements
接口定义的是功能，一种只有公用全局常量(public static final )和抽象方法的定义的特殊抽象类，而没有变量和方法的实现。(抽象方法和常量值的定义的集合)
    与类并行的一个概念：class---类；interface---接口


接口中含有：静态类和抽象方法，以及默认方法(jdk1.8以后出现的，用default来)，可以通过实现类来创建对象并调用默认方法。在实现类中也可以重写接口中的默认方法。如果在实现类重写了，调用的就不是接口中的默认方法，而是实现类中对接口的默认方法重写的方法。


SocketOutputStream.write(SocketOutputStream.java:159)

静态内部类：创建静态内部类的对象：可以直接通过外部类调用静态内部类的构造器

非静态内部类：创建非静态的内部类的对象：必须先创建外部类的对象，通过外部类的对象调用内部类的构造器 


浅复制：被复制对象的所有变量都含有与原来的对象相同的值,而其所有的对其他对象的引用都仍然指向原来的对象。一个对象中的字段有的是值类型的，有的是引用类型的。对于值类型字段来说，它的值就是简单的值，而对于引用类型来说，它的值是地址。
浅复制在复制时，将这个对象的值字段和引用字段（均为非静态字段）全部复制过去，获得了这个对象的值和地址。
即：当其中一个对象的引用字段所指向的地址中的变量变化时，所有浅复制对象中的该引用字段都会发生变化。

深复制：被复制对象会将所有非引用类型的字段复制给新对象，同时将引用类型所指向地址中存的对象复制给新的对象。


浅复制就是在复制对象的时候，只复制了对象中的变量值，而没有重新开辟一个空间给新的对象，也就是没有复制其引用的地址Object或者引用的对象
深复制就是把要复制的对象和其所引用的对象都复制了一遍。

就是在引用的对象也要写上覆盖Object中的clone方法 

数组的复制:1)使用循环逐个地复制数组的元素;
           2)使用System类中的静态方法arraycopy，但两个数组占有独立的内存空间
           3)使用clone方法复制数组

final特点：

1：这个关键字是一个修饰符，可以修饰类，方法，变量。

2：被final修饰的类是一个最终类，不可以被继承。

3：被final修饰的方法是一个最终方法，不可以被覆盖。

4：被final修饰的变量是一个常量，只能赋值一次。


设计模式:单例模式(保证类在内存中只有一个对象……A.构造方法私有；B.在成员位置自己创建一个对象；C.通过一个公共的方法提供访问)
                  1)饿汉式：类一加载就创建对象
                  2)懒汉式：使用的时候才创建对象
         
         工厂模式：一个接口的实现类来new创建实例对象(另一个接口的实现类)

         模板(方法)模式:一定实现的方法在抽象类中设计为可以实例的普通方法(在此方法中一定要有实现抽象类中的抽象方法)，不一定实现的方法设计为抽象方法，在继承类中来实现这个抽象方法。


Java中创建（实例化）对象的五种方式:
    1、用new语句创建对象，这是最常见的创建对象的方法。
    2、通过工厂方法返回对象，如：String str = String.valueOf(23); 
    3、运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。如：Object obj = Class.forName("java.lang.Object").newInstance(); 
   4、调用对象的clone()方法。
   5、通过I/O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。

方法的参数传递机制：值(形参为基本数据类型(数据域)和引用类型(内存地址值))传递

形参和实参：

  形参：方法声明时，方法小括号内的参数
  实参：调用方法时，实际传入参数的值


成员变量（堆）、局部变量（栈）、全局变量、静态变量（方法区-也就共享数据区）：

      （成员变量有默认初始值，而局部变量没有）
      局部变量：声明在某个方法类的变量，方法的参数和某个方法块内，它只在定义它的方法内有效。执行到它的时候直接在栈中开辟内存并使用的。当局部变量脱离作用域，存放该作用域的栈指针，栈顶与栈底重合即为释放内存，速度是非常快的。
      成员变量（实例变量），只有在的这个类是最外面的那个类的时候（在类中，方法外），叫做全局变量；也叫某个全局类的属性，如果是全局类的行为（方法）叫做成员函数，类的实例化就叫对象。调用：对象调用。存储在堆内存的对象中，所以也叫对象的特有数据。；
      静态变量（类变量）：用static修饰的全局变量，在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期--一直持续到整个"系统"类关闭。调用：类名调用  也可以用对象调用。存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。；
     注意――如果某个方法中的局部变量的名字与全局变量的名字相同  则该全局变量在这个方法中暂时失效 



方法的可变个数形参：形参类型后增加三点(...) 


bytes值不管是正数还是负数，在底层都是以补码的形式存储。


This：代表是本类类型的对象引用。this.成员变量=形参对象

Super：代表是子类所属的父类中的内存空间引用。直接父类对象引用,通过super访问父类中那些被子类覆盖的属性和方法。

this 和 super：1）this对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；

               2）this对象后面跟上 () 调用的是本类中的对应参数的构造函数。这个必须在其构造器内部的第一行。
               This：代表是本类类型的对象引用。

               Super：代表是子类所属的父类中的内存空间引用(属性、成员方法、构造器)。
由于有return this而产生的方法链
在get和set方法中使用this来区分方法中的带参和本类的对象

this关键字可以用于引用类的隐藏数据域(属性)
this.a=a;//后面的a表示形参变量，this.a中的a表示类变量

数据域(属性)：专门存放数据的存储空间

修饰构造器的时候，this(形参列表)或者super(形参列表)必须都要声明在构造器首行。

构造器（构造方法）：父类中一定含义构造器，才能在子类中的构造器第一行总是使用super来（没有创建系统会自动创建）继承，但是Object构造器不需要（因为没有父类构造器）。无参构造器和有有参构造器。构造方法没有返回类型。
可以在申明其方法：类 变量 =new +构造器(参数列表)
构造器和类同名，其中类名必须是public class类型修饰。

类中若存在n个构造器，那么最多有n-1个构造器中使用this。

StringBuffer 和StringBuilder:　StringBuilder：线程非安全的,效率高()；
                               StringBuffer：线程安全的（同步synchronized方法）
            1.如果要操作少量的数据用 = String
            2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
            3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer
            三者在执行速度方面的比较：StringBuilder>StringBuffer>String
        String数组不可变字符序列数组，而StringBuilder和StringBuffer可以改变字符序列数组，可通过arraycopy拷贝到另一个新数组扩容数组，没有封装。


拷贝：


重写(不同类中)：重写的方法与被重写的方法拥有相同的方法签名（返回值类型，方法名，参数列数），但可以定义自己的行为
      访问权限不能比父类中被重写的方法的访问权限更低。
      父类的成员方法只能被它的子类重写。
      声明为final的方法不能被重写。
      声明为static的方法不能被重写，但是能够被再次声明。
      子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
      子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
      重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
      构造方法不能被重写。

重载(同类中)：一个类当中，有方法名相同，(形参)参数不同的方法，称为重载
　　  *不能只改返回值：不能根据方法的返回进行重载


继承父类方法和实现接口：


数据类型：
    基本数据类型和包装类之间可以自动装箱和自动拆箱
    
    基本数据类型、包装类 --->String类:调用String类的重载的valueOf(Xxx x)方法

    String类--->基本数据类型、包装类:调用包装类的parseXxx(String str)方法或者调用包装类中的相对应的构造器。

   String--->StringBuffer 

   2.字符串与字节数组间的转换 ①字符串---->字节数组:调用字符串的getBytes() 
                              ②字节数组---->字符串：调用字符串的构造器
   *
   3.字符串与字符数组间的转换 ①字符串---->字符数组：调用字符串的toCharArray();                           ②字符数组---->字符串:调用字符串的构造器

    public static Integer valueOf(String s) throws NumberFormatException {
        return Integer.valueOf(parseInt(s, 10));
    }

    public Float(String s) throws NumberFormatException {
        value = parseFloat(s);
    }

    public Integer(String s) throws NumberFormatException {
        this.value = parseInt(s, 10);
    }

    1）：(自动装箱)基本数据类型：整型（byte、short、int、long、char）、浮点类型（float、double、boolean）---->封装成对象（包类），为自动装箱（隐藏了底层调用了调用包装类的valueOf方法）e.g.  Integer i1=100;隐藏了->（Integer i1=Integer.valueOf(100);）或者Integer i2=new Integer(100);---调用包装类中的构造器

         (自动拆箱)包类转换成对应的基本数据类型，为自动拆箱（隐藏了底层调用包装类的intValue方法。）e.g.  int i2=i1;隐藏->(int i2=i1.intValue();)---调用包装类中的intValue()方法。此方法相当于强制转型相对应的基本数据类型
    //int基本数据类型不需要强制性转换
    public short shortValue() {
        return (short)value;
    }

    2）：引用数据类型: 数组、类、接口、字符串*、枚举、标注。要创建引用的类型必须new出来一个对象。Byte、Intrger、Short、Long、Character
    
    3) : 值传递和引用传递：

Java中的参数传递机制：值传递机制
形参是基本数据类型---[值传递]    

基本数据类型赋值都属于值传递,值传递传递的是实实在在的变量值,是传递原参数的拷贝,值传递后，实参(调用方法时,参数列表中的参数)传递给形参(声明方法时，参数列表中的参数)的值，形参发生改变而不影响实参。

形参是引用数据类型---[引用传递]

引用类型之间赋值属于引用传递。引用传递传递的是对象的引用地址,也就是它的本身(自己最通俗的理解)。

引用传递：传的是地址，就是将实参的地址传递给形参，形参改变了，实参当然被改变了，因为他们指向相同的地址。

引用和我们的指针差不多,但是它不又不需要我们去具体的操作

 [内存分配]

一个具有值类型（value type）的数据存放在栈内的一个变量中。即是在栈中分配内存空间，直接存储所包含的值，其值就代表数据本身。

值类型的数据具有较快的存取速度。


一个具有引用类型（reference type）的数据并不驻留在栈中，而是存储于堆中。即是在堆中分配内存空间，不直接存储所包含的值，而是指向所要存储的值，其值代表的是所指向的地址。当访问一个具有引用类型的数据时，需要到栈中检查变量的内容，该变量引用堆中的一个实际数据。引用类型的数据比值类型的数据具有更大的存储规模和较低的访问速度。

Java中有垃圾回收机制，栈内存中的变量随着方法的结束内存自然销毁了，而用引用类型的时候，当方法结束的时候，这个对象可能被另一个引用类型所应用，不会销毁，只有当一个对象没有任何引用变量引用的时候，垃圾回收机制才会回收

(容量)级别从低(小)到高(大)为：byte,char,short(这三个平级)-->int-->float-->long-->double

自动类型转换：从低级别到高级别，系统自动转的；当要从高级别到低级别就必须强制类型转换。

基本数据类型自动转换：
 byte-->short,char -->int -->long
 float -->double
 int -->float
 long -->double
当char\byte\short之间做运算时，默认的结果为int类型，不管一种类型之间做运算，结果也是int类型

char只能表示一个字符


java分了5片内存。

     1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。

     栈：存储的都是局部变量 ---存放基本类型的变量数据和对象的引用( 函数中定义的变量，函数上的参数，语句中的变量);
         只要数据运算完成所在的区域结束，该数据就会被释放。

     堆：用于存储数组和对象(new出来的对象)，也就是实体。啥是实体啊？就是用于封装多个数据的。
    1）：每一个实体都有内存首地址值。
    2）：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。
    3）：垃圾回收机制。

     方法区：字符串常量池

     静态域：类变量

堆（Heap）栈（Stack）
    内存分配方面：
    1.堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。包含成员变量
       可能用到的关键字如下：new、malloc、delete、free等等操作的对象(创建..)
    2.栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值，对象的引用等。其操作方式类似于数据结构中的栈。
    
    3.常量池：存放字符串常量和基本数据类型常量(public static final)



成员变量和局部变量的区别：

     1：成员变量直接定义在类中。

        局部变量定义在方法中，参数上，语句中。

     2：成员变量在这个类中有效。

        局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。

     3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。

        局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。


try{


}catch{


}finally{

}
执行try语句中return语句
，不过并没有直接返回结果，而是先去执行finally语句，再返回try中return的结果。
如果finally语句中有return语句，返回finally中return结果，就不能返回try中的return结果。




多线程：一种是单继承Thread类(此类也是继承Runable接口)，另外一种是实现Runnable接口。实现的方式优于继承，避免了继承的单继承机制。有共享数据的资源，实现Runnable接口更适合

  通过调用某个线程的start()方法来启动线程，并执行了这个线程的run()方法，要想启动一个相册必须要先创建一个线程。
注意：然后执行run方法Thread()类中有start()直接来启动，而Runnable()接口没有start()方法，可以再新建以Runnable为形参构造器的一个对象
     Thread t=new Thread(Runnable r);


      多线程同步：共享数据
      多线程异步：

      线程的通信：


共享变量(静态属性，也就是类属性)：如果一个变量在多个线程的工作内存(JMMM描述了Java程序中各种变量-线程共享变量的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。)中都存在副本，那么这个变量就是这几个线程的共享变量。


多线程可见性(volatile、synchronized、Lock、final一个线程对共享变量值的修改，能够及时地被其他线程看到)和原子性：
一)Synchronized用来给对象的方法或者代码块加锁并在最后要解锁来实现原子性(同步-多个线程都要加锁)和内存可见性，在Java内存模型(JMM)中规定：1)线程解锁前，必须把共享变量的最新值刷新到主内存中

二)volatile放在代码块或者方法前面修饰可实现内存可见性(共享变量的值要及时更新到主内存中)


1、启动线程，必须是Thread类中的start()方法来启动。
2、currentThread()：静态的，调取当前的线程
3、isAlive():判断当前线程是否还存活
4、 * 设置线程的优先级
    * getPriority() ：返回线程优先值 
    * setPriority(int newPriority) ：改变线程的优先级


死锁：




指令重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化（单线程中as-if-serial避免重排序）


常用的集合类:实现Collection接口的（List,Set以及实现类）,Map
  Collection：代表一组对象，每一个对象都是它的子元素。
  Set：不包含重复元素的Collection。
  List：有顺序的collection，并且可以包含重复元素。
  Map：可以把键(key)映射到值(value)的对象，键不能重复。

 * 3.集合
 *     Collection接口
 *     		|------List接口：存储有序的，可以重复的元素
 *     				|------ArrayList（主要的实现类）、LinkedList（对于频繁的插入、删除操作）、Vector（古老的实现类、线程安全的）
 *     		|------Set接口：*底层存储*无序的，不可重复(重写hashCode()方法和equals(方法),且要一致)的元素使用哈希算法来进行存储。
 *     				|------HashSet(完全无序(有规则(不是随机性)、不可重复))、LinkedHashSet(通过链表并按照添加进去的顺序进行遍历)、TreeSet(重写hashCode()方法、equals()方法和实现Comparable接口中的compareTo抽象方法(按照哪个属性进行排序--自然排序；定制排序:创建一个实现了Comparator接口的类对象,并在其对象中按照哪个属性进行排序的算法)，要一致)
 *     Map接口：存储“键-值”对的数据
 *     		|-----HashMap、LinkedHashMap、TreeMap、Hashtable(子类:Properties)

jdk1.8版本的HashMap红黑树实现

TreeSet中添加的元素必须是同一类型的。


数据结构<接口、类>(也叫做容器):是以某种形式将数据组织在一起的集合。数据结构不仅存储数据，还提供一些方法来访问和处理数据的操作，主要包括以下的几种接口和类:
   枚举（Enumeration）:(不属于数据结构)一种从数据结构中取回连续元素的方式。
   位集合（BitSet）
   向量（Vector）:Vector的大小能根据需要动态的变化。和数组一样，Vector对象的元素也能通过索引访问
   栈（Stack）: 实现了一个后进先出（LIFO）的数据结构。
   字典（Dictionary）
   哈希表（Hashtable）
   属性（Properties）
   集合框架(Collection):规则集(Set)、线性表(List)和队列(Queue)

算法:


反射机制：就是在运行状态中，对于任意一个类或者是对象，都能够调用它的任意一个方法和属性；-----这种动态获取的信息以及动态调用对象的方法的功能


Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法


反射相关的主要API：                
         java.lang.Class:代表一个类                       java.lang.reflect.Method:代表类的方法
         java.lang.reflect.Field:代表类的成员变量         java.lang.reflect.Constructor:代表类的构造方法


	 * java.lang.Class:是反射的源头。
	 * 我们创建了一个类，通过编译（javac.exe）,生成对应的.class文件。之后我们使用java.exe加载（JVM的类加载器完成的）
	 * 此.class文件，此.class文件加载到内存以后，就是一个运行时类，存在在缓存区。那么这个运行时类本身就是一个Class的实例！
	 * 1.每一个运行时类只加载一次！
	 * 2.有了Class的实例以后，我们才可以进行如下的操作：
	 *     1）*创建对应的运行时类的对象
	 *     2）获取对应的运行时类的完整结构（属性、方法、构造器、内部类、父类、所在的包、异常、注解、...）
	 *     3）*调用对应的运行时类的指定的结构(属性、方法、构造器)
	 *     4）反射的应用：动态代理


动态代理：在运行时动态生成代理类。不需要我们像静态代理那个去手动写一个个的代理类。生成动态代理类有很多方式：Java动态代理，CGLIB，Javassist，ASM库等。
   1、动态代理类(实现InvocationHandler接口)--声明为h了，并重写其invoke()方法
   2、Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),h);
  //注：obj：被代理类对象 ； h:实现了InvocationHandler接口的实现类的对象


静态代理：要求被代理类和代理类同时实现相应的一套接口；通过代理类的对象调用重写接口的方法时，实际上执行的是被代理类的同样的
方法的调用。


类加载器：把类(class)装载进内存



泛型：泛型类(包含集合类)，如果泛型类是一个接口或者是抽象类，就不能创建泛型类的对象；不能再catch中使用泛型；从泛型类派生的子类，泛型类型需具体化。所以在泛型类中使用静态方法(即在static方法中不能使用泛型的声明)

1)定义一个类为泛型类型: 将泛型类型放在类名之后
2)定义一个方法为泛型类型:将泛型类型放在方法返回类型之前

//可以读取声明为通配符的集合类的对象，但是读取的返回值都是为Object类型
//不允许向声明为通配符的集合类中写入对象。唯一例外的是null

泛型类是被它的所有实例(通过extends来实例泛型类)所共享，在运行时被消除泛型为原始类型;泛型的主要优势是能在编译是而不是运行时发现错误
   A<E extends B> c(D d){
       //泛型表示向后兼容
   }
   A<? extends B> c(D d){
      //通配类型
   }
   

限制：
   new E();   //不能使用泛型类型来实例化，由于运行时是会消除泛型成原始类型，E不可用，已消失(泛型擦除是指在继承(实现)或者使用时没有指定具体的类型)
   new E[];  //不能使用泛型类创建泛型数组;跟以上一样原理
   一个泛型类中的静态方法的参数和属性方法不能是泛型类型;泛型方法和泛型类不能是静态方法和静态类(不能实例化，E就不能实例)
   泛型类和泛型方法不能抛出异常，在异常类中不能使用泛型类型参数


枚举类：私有化构造器(private、final)，在内部直接调用自己的构造器来创造对象(个数已经在枚举类中确定，如果是一个叫单例模式)做为公有的静态类属性(即全局常量)。


Java序列化：是一种来处理对象流的机制，是指把Java对象转换为字节序列的过程；而Java反序列是指把字节序列恢复为Java对象的过程。
采用Java序列化与反序列化技术，一是可以实现数据的持久化，在MVC模式中使用；二是可以对象数据的远程通信。


实现序列化机制的对象对应的类的要求：
    ①要求类要实现Serializable接口②同样要求类的所有属性也必须实Serializable接口
    ③ 要求给类提供一个序列版本号：private static final long serialVersionUID;
    ④属性声明为static 或transient的，不可以实现序列化



对象流： 将对象的内容进行流花，即转换成二进制字节流，并可以对流化后的对象进行读写操作，也可以将流化后的对象传输于网络之间（要想将对象传输于网络必须进行流花）


在Object类中的equals方法:相当于==，都是比较的是内存地址。
       public boolean equals(Object obj) {
        return (this == obj);
       }

在String 包装类 File类 Date类中重写Object类中的equals方法:使之比较的是对象内容

==和equals之间区别：
     ==：      比较的是两个字符串内存地址的数值是否相等，属于数值比较；
     equals()：比较的是两个字符串的内容，属于实体内容比较。


一、java当中的数据类型和“==”的含义：
 
基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
复合数据类型（类）：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。
注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。
 
二、equals()方法介绍：
 
JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被复写了，如String、Integer、Date。
在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 
所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。
判断字符串相等时使用equals();
java.lang.String的intern()方法"abc".intern()方法的返回值还是字符串"abc"，检查字符串池里是否存在"abc"这么一个字符串，如果存在，就返回池里的字符串；如果不存在，该方法会 把"abc"添加到字符串池中，然后再返回它的引用。


功能块（方法的含义）：实现某个功能的语句块的集合。方法的原子性（一个方法只完成1个功能）。

str.trim().//trim()是去掉首尾空格
str.replace(" ", ""); //去掉所有空格，包括首尾、中间
str.replaceAll(" +",""); //去掉所有空格
str = .replaceAll("\\s*", ""); //可以替换大部分空白字符,不限于空格。
 \s 可以匹配空格、制表符、换页符等空白字符的其中任意一个
equalsIgnoreCase,不区分大小写
 

mysql存储过程：也就是封装sql
create procedure p1()
begin
select  * from t_news;
end $         //mysql存储过程 简单实例


6.  final, finally, finalize的区别

final 修饰符（关键字）用于声明属性、方法和类，分别表示属性不可变（常量），方法不可覆盖（可以被重载），类不可继承-不能被子类重写。

finally是异常处理语句结构的一部分，表示总是执行。 

finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。


34、谈谈final, finally, finalize的区别
答：final―修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载
finally―再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）
finalize―方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的


“is-a”(是)代表的是类之间的继承关系，“has -a”(包含)代表的是对象和它的成员的从属(组合)关系。同一种类的对象，通过它们的属性的不同值来区别，把继承中的父类做为属性放在继承中所谓的子类中。


面向对象的三大特性：
  多态：要求：1）继承，2）重写，3）父类的引用(类型)指向子类对象(类型)->Parent p = new Child();---虚拟方法调用(实际是执行子类重写父类的方法)
      4）实现方式：①回调callback-多态的使用，先设计一个模板方法模式，其中有一处实现方法会改变。
                   ②接口实现，继承父类进行方法重写，同一个类中进行方法重载。

子类对象的多态性对子类属性和子类的静态方法不起作用。final、private以及静态方法没有多态性。


动态绑定：是多态的一种，虚方法会根据运行时的对象进行调用。(重写(Override))方法在运行时进行动态绑定。使用对象信息来完成

静态绑定(前期绑定)：使用类中private或static或final修饰的变量或者方法(重载(Overload)),会根据编译时的类进行调用。使用类信息来完成,在本类中。方法中由final、static、private和构造方法是前期绑定。

     

  继承：一个类只能继承一个父类（或者是抽象类），但可以实现多个接口
 
  封装/隐藏(encapsulation)：……高内聚，低耦合,可以通过private控制符来隐藏属性，然后在这个包类通过setter和getter方法(必须公开public)使其他包来访问其属性


在多态时对象的父类引用类型转换 ：instanceof
   格式为：if(对象的实例 instanceof 对象类型){
              父类引用类型转换
           }


递归:在方法中调用自己的方法，实现一个循环效果。


存储过程（通过用户调用存储过程名来执行的）：将一些固定的操作集中起来由数据库服务器来完成，以实现某个任务。(记录集)……它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。需要执行的多条SQL语句封装到一个独立单元，用户只需要调用这个单元就可以达到目的--->
       1）、简化复杂操作：一人编写，多人调用
       2）、增加数据独立性：把数据库的基础数据个程序（或者用户）分隔开来，减少耦合性
       3）、提高安全性，降低网络的通信量（提高通信效率）：通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。
       4）、实现表字段完整性：对表中所有的字段进行完整性验证


触发器（某些事件触发时，由数据库自动执行，执行对用户来说是透明的）：对表进行插入、更新、删除的时候会自动执行的一种特殊类型的存储过程，一般用在check约束更加复杂的约束上面。
   事件操作类型……1）用户在指定的表或视图中做的DML操作：update操作、insert操作和delete操作（删除特定的表或视图中的数据）
                   2）DLL操作：create操作、alter操作（修改对象）、drop操作（删除对象）          
                   3）系统和用户数据库事件：用户的登录或者注销，数据库的打开或关闭，特定的错误信息。
                   4）instead of触发器




格式：create or replace trigger 触发器名称 
      before|after|instead of            ――>[触发类型]
      delete|insert|update [ of 列名]
      on 表名                            ――>[作用对象(数据表、视图等)]
      [for each row]                     ――>[行级触发器标识]
      begin
      PL/SQL语句;                        ――>[触发器被激活时所执行的代码]
      end;

  PL/SQL语句：insert into 表名 values (:old.column_name,……，sysdate);



语句级触发器：如果一个触发器在用户每次进行DML操作时被激发且执行一次，而不管这个DML操作影响了多少行数据，这个触发器就是语句级触发器
限制表的操作，限制用户权限

例子：创建语句级触发器，控制每个月的28号不允许操作表中的数据
      create or replace trigger 触发器名称
      before delete   ――>表明新建触发器的触发时机为delete动作之前
      on 表名         ――>表明触发器创建于表-表名之上
      begin 
      if to_char(sysdate,'dd')=28
      then dbms_outputput_line('当前时间不允许删除数据');
      end if;
      end;

      验证是否创建成功
      select sysdate from dual;
      delete from 表名 where 列名 in(数据);


例子：限制用户权限
    create or replace 触发器名
       before insert or delete    ――>利用or关键字来指定多个激活动作
       on 表名
      begin 
       if user!='TEST2016' then
         raise_application_error(-20001,'权限不足，不能向数据表中插入数据');

      end if;
    end;
 


触发器谓词：inserting、updating和deleting，利用if语句来判断触发器的激活动作是否为insert、update和delete，并向记录表（创建）中插入相应的记录；先创建一个记录表，然后创建一个触发器，用来将实际操作的信息插入记录表中。
  例子：1)创建一条记录表
         create table cus_log
         (user_name varchar2(20),action varchar2(20),log_time date);

        2）创建一个触发器
          create or replace trigger tr_cus_log
          after insert or delete or update 
          on customersnew
           begin
            if updating then 
              insert into cus_log values(user,'update',sysdate);
            end if;
            if insterting then
               insert into cus_log values(user,'insert',sysdate);
            end if;
            if deleting then
               insert into cus_log values(user,'delete',sysdate);
            end if;
           end;
        
        3)对表进行CRUD操作
           insert into customersnew(customer_id,cust_first_name)
            values(994,'Jackhman');
           update customersnew set cust_first_name='Mark'
            where customer_id=994;
           delete from customersnew where customer_id=994;
        4)查询记录表(记录触发动作的表)
          select * from cus_log;
        5)回滚对数据库的操作
          rollback
       
      
行触发器：创建的一个表的触发器，在对这个表进行DML操作时，每影响一行数据，该触发器都将被激发执行一次，那么这个触发器就是行触发器


:old.column_name         ――>一定要在触发时机为before update or delete 在更                               新和删除操作之前(不能使用insert操作，因为insert操作并不存在对应的历史数据)，引用某个列的值时要在前面叫上":",在其他地方则不用使用":"

create table categories_history(
   category_id int NOT NULL AUTO_INCREMENT,
   category_description VARCHAR(50) NOT NULL,
   category_name VARCHAR(1000) NOT NULL,
   op_date DATE,
   PRIMARY KEY ( category_id )
);


函数（用户显式地调用才执行）：
    nvl函数：如果oracle第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第一个参数本来的值。格式为:NVL(a,b)

自定义函数：
create [or replace] function function_name

　　[(parameter_list)]

　　return datatype

　　{is/as}

　　[local_declarations]

　　begin

　　　　executable_statements;

　　[exception

　　　　exception_handlers;]

　　end;

　说明：

　　function_name：函数名称。

　　parameter_list：函数列表，可选。

　　return 自居：指定函数的返回类型，不能指定大小。

　　local_declarations：局部变量声明，可选。

　　executable_statements：要执行的PL-SQL语句。

　　exception_handlers：异常处理，可选。

　　or repalce：是否覆盖，可选。


事务和锁：事务是用户定义的一个数据库操作序列，是一个不可分割的整体，这个操作要么全做，要么全不做。


Arrarys.sort(a);//使用二分法查找，必须先对数组进行排序

使用增强for循环进行遍历：for(String value:list){
                           System.out.println(value); 
                        }
普通for循环遍历：       for(int i=0;i< list.size();i++){
                           System.out.println(list.get(i)); 
                       }
相对于增强for循环进行的遍历效率相对高些

常用类：java.util
Collections容器接口：Set和List(有序可重复-索引index)
      List容器中的方法：void add(int index, E element);
      1）ArrayList：底层实现是数组，所以。查询快，增删改慢；
      2）LinkedList：底层实现是双向链表，所以，查询慢，增删改快；
      3）Vector:线程安全，效率低，多个线程共享的时候使用。ArrayList和LinkedList线程不安全，效率高




I/O：转换流---InputStreamReader  OutputStreamWriter
       解码：字符串--->字节数组
       编码：字节数组--->字符串


 * 抽象基类	    节点流（文件流）     缓冲流（处理流的一种,可以提升文件操作的效率）
 * InputStream      FileInputStream	 BufferedInputStream
 * OutputStream	    FileOutputStream     BufferedOutputStream  (flush())
 * Reader	    FileReader		 BufferedReader  (readLine())
 * Writer	    FileWriter		 BufferedWriter  (flush())


字符流：字符流在操作时使用了缓冲区，通过缓冲区再操作文件

字节流：字节流直接操作文件，不会使用到缓冲区

节点流：FileInputStream、FileOutputStream



拷贝(推到旧的数组创建一个新的数组，然后把旧数组对象copy到新的数组)--->扩容：StringBuffer和StringBuilder，以及ArrayList……
          1)先把旧数组进行arraycopy到一个新的数组，
               Object[] newArray=new Object[size*2+1];
               System.arraycopy(elementData,0,newArray,elementData.length);
               elementData=newArray;
          或者：for(int i=0;i<elementData.length;i++){
                 newArray[i]=elementData[i];    
                }
           或者：public void add(E ele){
		if(this.size==elem.length){ //容量不够 -->扩容
			elem=Arrays.copyOf(elem, elem.length+5);
                        List a=Arrays.asList("","");//数组作为列表			
		}
		
		elem[size] =ele; //数组中加入元素 最后
		size++; //实际大小+1		
	     }

面向对象和面向过程：1）面向过程(POP)就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 
                   2）面向对象(OOP)是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为


   进程：操作系统 调度程序 静态概念--->一个进程中的线程共享相同的内存单元/内存地址空间→可以访问相同的变量和对象，而且它们从同一堆中分配对象→通信、数据交换、同步操作。每个进程都是独立的，由3部分组成cpu,data,code
   线程：Thread，是进程中一个“单一的连续控制流程”/执行路径，在进程内多条执行路径（多线程相当多个CPU），线程又被称为轻量级进程,真正的多线程是在多个CPU下运行。
  
 
   启动线程为start()；而重写Thread类或Runnable接口中的run()方法，这个方法内实现子线程要完成的功能。run()执行完成线程就死亡。

   多线程的生命周期：new Thread(){
                    
                    }.start();


   死锁：多线程同步时候遇到的问题，不同线程分别占用对方需要的同步资源不放弃，都在等在对方放弃自己所需要的同步资源.
   
   延迟加载：


   双重检查加锁：单例模式对多线程进行处理的优化方法(DCL)

工程的聚合、继承、依赖
   