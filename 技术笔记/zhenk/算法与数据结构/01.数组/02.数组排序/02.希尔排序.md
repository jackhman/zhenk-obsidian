## 1、基本思路🍉
希尔排序法又称缩小增量法，该方法因 D.L.Shell 于 1959 年提出而得名。希尔排序法的基本思想是：首先取一个整数n（小于序列元素总数）作为间隔，把待排序数字中所有数分成几个组，所有间隔相同的数分在同一组内，并对每一组内的数进行排序。缩小间隔n，重复上述分组和排序的工作。当达到n=1 时，所有记录统一在一组内排好序。

其实从上面的希尔排序的思想中也能看出希尔排序的实现步骤：

1. 选n，划分逻辑分组，组内进行直接插入排序。
2. 不断缩小n，继续组内进行插入排序。
3. 直到n=1，在包含所有元素的序列内进行直接插入排序。

**其中缩小间隔gap 的取法有多种。最初 Shell 提出取 gap =n/2，gop =gap/2，直到 gap =1。后来 Knuth 提出取 gap =gap/3 +1。还有人提出都为好有人提 gap 互质为好。无论哪一种主张都没有得到证明。**

![](希尔排序原理静图.png)

![](希尔排序原理动图02.gif)

## 2、代码实现🍉
```java
public class Main {
    public static void shellSort(int[] arr){
        /*初始化划分增量*/
        int n = arr.length;
        int temp;
        /*每次减小增量，直到n = 1*/
        while (n > 1){
            /*增量的取法之一：除2向下取整*/
            n = n/2;
            /*对每个按gap划分后的逻辑分组，进行直接插入排序*/
            for (int i = n; i < arr.length; ++i) {
                if (arr[i-n] > arr[i]) {
                    temp = arr[i];
                    int j = i-n;
                    while (j >= 0 && arr[j] > temp) {
                        arr[j+n] = arr[j];
                        j -= n;
                    }
                    arr[j+n] = temp;
                }
            }
        }
    }
    public static void main(String[] args) {
        int[] arr={1,8,6,29,10,14,37,48};//排序结果为1,6,8,10,14,29,37,48
        shellSort(arr);
    }
}
```

## 3、代码优化🍉

### Ⅰ、🧁希尔排序优化（二分）

由于希尔排序是基于插入排序的，所以在插入排序中也可运用直接插入排序中的优化方式，所有也可以以二分折中的方式来优化希尔排序。

```java
public class Main {
    public static void shellSort(int[] arr) {
        int j, left, mid, right, temp;
        int n = arr.length;
        while (n > 1) {
            n /= 2;
            for (int i = n; i < arr.length; i++) {
                left = 0;
                right = i - 1;
                temp = arr[i];
                while (left <= right) {
                    mid = (left + right) / 2;
                    if (arr[mid] > temp) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }
                for (j = i - n; j >= right + 1; j-=n) {
                    arr[j + n] = arr[j];
                }
                arr[j + n] = temp;
            }
        }
    }
    public static void main(String[] args) {
        int[] arr = {1, 8, 6, 29, 10, 14, 37, 48};//排序结果为1,6,8,10,14,29,37,48
        shellSort(arr);
    }
}
```

### Ⅱ、🧁Knuth序列

我们首先计算出初始的间隔值gap，然后在每次循环中，将gap逐步减小，直到变为1。在每次循环中，对于每个间隔为gap的子序列，我们采用插入排序的方式进行排序。`h(min) = 1, h = h*3 + 1`

```java
public static void shellSort(int[] arr) {
    int n = arr.length;
    int h = 1;
 
    // 计算间隔值
    while (h < n / 3) {
        h = 3 * h + 1;
    }
 
    while (h >= 1) {
        // 对每个子序列进行插入排序
        for (int i = h; i < n; i++) {
            for (int j = i; j >= h && arr[j] < arr[j - h]; j -= h) {
                swap(arr, j, j - h);
            }
        }
 
        // 缩小间隔值
        h /= 3;
    }
}
 
// 交换数组中两个元素的位置
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

- 计算间隔值时，只需要计算一次，并使用while循环找到最大的合适值。
- 使用插入排序对每个子序列进行排序，因为插入排序对于小数组来说效率更高。
- 在插入排序中，使用间隔值h来代替常规的1。

## 4、优缺点🍉

🧁优点：

1. 希尔排序的时间复杂度较低。在大多数情况下，其时间复杂度为O(n^1.3)，尤其适用于中等大小的数组。
2. 希尔排序不像其他排序算法需要大量的额外空间，因此可以在内存有限的情况下使用。
3. 希尔排序是一种稳定的排序算法，即相同元素在排序前和排序后的位置不会发生改变。

🧁缺点：

1. 希尔排序的实现较为复杂。它涉及到多个子序列和间隔值的计算，这增加了程序的代码量和阅读难度。
2. 希尔排序由于具有不确定性，因此很难预测其排序时间。在某些情况下，其时间复杂度可能会退化到O(n^2)或更高，导致性能下降。
3. 希尔排序的间隔值选择对于排序时间的影响非常大。如果选择错误的间隔值，可能会导致排序时间变得非常长。

综上所述，希尔排序是一种高效的排序算法，但实现较为复杂，且对于间隔值选择敏感。在某些情况下，可能存在性能问题。因此，在实际应用中，需要根据具体情况来选择是否使用希尔排序。

## 5、总结🍉

1. 希尔排序是对直接插入排序的优化。
2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。
3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些书中给出的希尔排序的时间复杂度都不固定。时间复杂度：平均情况：(nlogn)~  o(n²) 。最好情况：o(n¹˙³)。最坏情况： o(n²) 。
4. 空间复杂度：0(1)
5. 稳定性：不稳定
6. 适用场景：待排序序列元素较少时