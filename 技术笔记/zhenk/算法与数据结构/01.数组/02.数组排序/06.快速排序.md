> [!tip] 快速排序实现原理
> * 快速排序（Quick Sort）是一种常用的排序算法，它基于分治的思想，通过将一个无序的序列分割成两个子序列，并递归地对子序列进行排序，最终完成整个序列的排序。<font color = red>双轴快排</font>。TimSort，冒泡排序的改进排序算法。
> * 选择一个元素作为枢轴元素（pivot），并围绕选定的主元素对给定数组进行分区（partition）。快速排序有很多不同的版本，它们以不同的方式选择枢轴。

1. 总是选择第一个元素作为 pivot。
2. 总是选择最后一个元素作为 pivot。
3. 随机选一个元素作为 pivot。
4. 选择中值作为 pivot。

QuickSort 中的关键步骤是 partition()。在数组中选择的一个元素为支点（pivot）, 把所有小于 pivot 的元素放到 pivot 左面, 大于 pivot 的放右边。这样数组 x[n] 会被划分成3个部分：

`x[0] , ... , x[pivot - 1]` 
`x[pivot]` 
`x[pivot+1] , ... , x[n]`

所有这应该是在线性时间内完成。

![[快速排序动图.gif]]

## 其基本思路如下
1. 选择数组中的一个元素作为基准（pivot）。
2. 将数组中小于等于基准的元素放在基准的左边，将大于基准的元素放在基准的右边。
3. 对基准左右两边的子数组分别重复步骤1和步骤2，直到子数组的大小为1或0（递归结束）。



## 具体步骤
1. 首先选择一个基准元素，通常为数组的第一个或最后一个元素。
2. 设置两个指针，一个指向数组的起始位置（低位），一个指向数组的结束位置（高位）。
3. 使用两个指针从两个方向同时遍历数组，直到两个指针相遇。
4. 从低位开始，比较当前元素与基准元素的大小关系：
    - 如果当前元素小于等于基准元素，则向右移动低位指针。
    - 如果当前元素大于基准元素，则向左移动高位指针。
    - 如果低位指针仍然在高位指针的左侧，则交换低位指针和高位指针所指向的元素。
5. 重复步骤4，直到低位指针与高位指针相遇。
6. 将基准元素与相遇位置的元素进行交换，确保基准元素位于其最终的排序位置。
7. 根据基准元素的位置，将数组分为两个子数组，并递归地对这两个子数组进行快速排序。

![[image-20231122184049802.png]]

## 代码实现
```java
public static void sort(int[] array, int low, int high) {  
    if (low >= high) {  
        return;  
    }  
    // 找到 数组划分后 pivot 下标,这时就划分了  
    int pivot = partition(array, low, high);  
    // 递归排序左序列  
    sort(array, low, pivot - 1);  
    // 递归排序右序列  
    sort(array, pivot + 1, high);  
}  
  
/**  
 * 分成四个区间的 array[l, i), array[i, j), array[j,r), array[r]  
 * 1. array[l] < array[i] < array[j] < array[r] * 2. array[r] 为pivot下标的轴数组  
 * 3. array[j,r) 为没有进行排序的未知数组  
 * 4. array[l, i) 为已经排好序小于array[r]的已知数组  
 * 5. array[i, j) 为已经排好序大于于array[r]的已知数组  
 *  
 * @param array  
 * @param low  
 * @param high  
 * @return  
 */  
static int partition(int[] array, int low, int high) {  
    // 1. 随机找出low 和 high 之间的一个数  
    int p = SortUtils.random(low, high);  
    // 2. 把pivot 放到最后  
    swap(array, p, high);  
    // 3. l,i,j开始都指向low; high为  
    int i = low;  
    for (int j = low; j < high; j++) {  
        if (array[j] <= array[high]) {  
            swap(array, i, j);  
            i++;  
        }  
    }  
    swap(array, i, high);  
    return i;  
}
    /**  
     * @param array      数组  
     * @param leftBound  左边界  
     * @param rightBound 右边界,用来表示 pivot  
     */
     static int partition2(int[] array, int leftBound, int rightBound) {  
        int pivot = array[rightBound];  
        int left = leftBound;  
        int right = rightBound - 1;  
        while (left <= right) {  
            while (left <= right && array[left] <= pivot) {  
                left++;  
            }  
            while (left <= right && array[right] > pivot) {  
                right--;  
            }  
  
            if (left < right) {  
                swap(array, left, right);  
            }  
        }  
        swap(array, left, rightBound);  
        return left;  
    }
```

---1: 7 3 2 10 8 1 9 5 4 6
before1 swap: left---> 0 right---> 8
before2 swap: left---> 0 right---> 8
---1: <font color = red>4</font> 3 2 10 8 1 9 5 <font color = red>7</font> 6 
before2 swap: left---> 3 right---> 7
---1: 4 3 2 <font color = red>5</font> 8 1 9 <font color = red>10</font> 7 6 
before2 swap: left---> 4 right---> 5
---1: 4 3 2 5 <font color = red>1</font> <font color = red>8</font> 9 10 7 6 
before2 swap: left---> 5 right---> 4
---1: 4 3 2 5 1 8 9 10 7 6 
before1 swap: left---> 0 right---> 3
before2 swap: left---> 0 right---> -1
---1: 4 3 2 5 1 | <font color = red>6</font> 9 10 7 <font color = red>8</font> 
before1 swap: left---> 1 right---> 3
before2 swap: left---> 3 right---> 2
---1: <font color = red>1</font> 3 2 5 <font color = red>4</font> | 6 9 10 7 8 
before1 swap: left---> 1 right---> 1
before1 swap: left---> 6 right---> 8
before2 swap: left---> 6 right---> 8
---1: 1 2 3 <font color = red>4</font> <font color = red>5</font> | 6 <font color = red>7</font> 10 <font color = red>9</font> 8 
before2 swap: left---> 7 right---> 6
---1: 1 2 3 4 5 6 7 10 9 8 
before1 swap: left---> 8 right---> 8
before2 swap: left---> 9 right---> 8
---1: 1 2 3 4 5 6 7 <font color = red>8</font> 9 <font color = red>10</font>
1 2 3 4 5 6 7 8 10 9 

## 算法性能
速度仅次于快速排序。

### 时间复杂度
最坏时间复杂度: $O(n^2)$
平均时间复杂度: $O(n \times \log n)$

>1. 已经排好序的避免最差时间复杂度：先判断是否排好序才就不需要快速排序或者使用mergeSort
>2. pivot随机取一个数

#### 如何分析
快速排序的平均时间复杂度为$O(n \times \log n)$，其中n是待排序元素的数量。下面是对快速排序时间复杂度的分析：

1. **划分操作的复杂度：** 快速排序的核心操作是划分，即将数组分为两个子数组，并确定一个基准元素的过程。这个划分的时间复杂度是$O(n)$，其中n是数组的大小。
2. **递归调用：** 在快速排序中，每次划分都会导致两个子数组。然后，对这两个子数组进行递归调用快速排序。因此，快速排序的递归树的深度是log n。
3. **总体时间复杂度：** 在每一层递归中，划分操作的时间复杂度为O(n)，而递归的深度为log n。因此，总体的时间复杂度是O(n log n)。
4. **最坏情况：** 在最坏的情况下，快速排序的时间复杂度为$O(n^2)$，即所有划分都是最不平衡的情况。这种情况通常发生在选择的基准元素总是导致最不平衡划分的情况下。然而，通过采用随机化的方法选择基准元素，可以降低出现最坏情况的概率。

总体来说，快速排序在平均情况下是一种高效的排序算法，但在最坏情况下的性能可能较差。在实际应用中，通常能够达到O(n log n)的时间复杂度，因此快速排序是一种被广泛采用的排序算法。

### 空间复杂度
$O(log n)$ 每递归（每层）一次需要有个临时变量

### 稳定性
稳定。


## 双轴快排
> [!tip] 双轴快排算法思想
> 双轴快速排序（Dual-Pivot QuickSort）是对传统快速排序的改进，由Vladimir Yaroslavskiy提出，最初用于Java中的Arrays.sort()。相比于传统的快速排序，双轴快排使用了两个基准元素而不是一个，从而可以在一次分区过程中同时对两个方向进行划分，提高了性能。

![[Arrays.sort源码分析.png]]


```java
import java.util.Arrays;

public class DualPivotQuickSort {

    public static void dualPivotQuickSort(int[] array) {
        dualPivotQuickSort(array, 0, array.length - 1);
    }

    private static void dualPivotQuickSort(int[] array, int left, int right) {
        if (left < right) {
            int[] pivots = partition(array, left, right);

            dualPivotQuickSort(array, left, pivots[0] - 1);
            dualPivotQuickSort(array, pivots[0] + 1, pivots[1] - 1);
            dualPivotQuickSort(array, pivots[1] + 1, right);
        }
    }

    private static int[] partition(int[] array, int left, int right) {
        if (array[left] > array[right]) {
            swap(array, left, right);
        }

        int pivot1 = array[left];
        int pivot2 = array[right];

        int i = left + 1;
        int j = right - 1;
        int k = left + 1;

        while (k <= j) {
            if (array[k] < pivot1) {
                swap(array, k, i);
                i++;
            } else if (array[k] >= pivot2) {
                while (array[j] > pivot2 && k < j) {
                    j--;
                }
                swap(array, k, j);
                j--;
                if (array[k] < pivot1) {
                    swap(array, k, i);
                    i++;
                }
            }
            k++;
        }

        i--;
        j++;

        swap(array, left, i);
        swap(array, right, j);

        return new int[]{i, j};
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {12, 11, 13, 5, 6, 7};

        System.out.println("Original Array: " + Arrays.toString(array));

        dualPivotQuickSort(array);

        System.out.println("Sorted Array: " + Arrays.toString(array));
    }
}

```