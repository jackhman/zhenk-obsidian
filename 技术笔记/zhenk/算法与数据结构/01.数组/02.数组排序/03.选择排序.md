## 介绍
>[!TIP] 选择排序的注意事项
>* 时间复杂度最高O(n²)的且不稳定的算法，不稳定性缘由：两个相等的数在排完顺序后其相对顺序会发生变化（可能会出现在排好序的那一段）。O(n²)的最耗时的是在内套的内循环代码
>* 找到最小的元素放到第一位并和原先的第一位元素对换（从小到大排序）
>* 不管是否有序都要从头到尾找一遍
>* 选择排序就是重复“<font color = red>从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换</font>” 这一操作的算法。在序列中寻找最小值时使用的是线性查找。

![[选择排序动图.gif]]

## 优化
1. 遍历一次由只找到最小或者最大值改成同时找出最大最小值，然后分别放到数组的头尾。
2. 下标为0的和后面一位数比较改成几个数中最大或最小值比较

## 代码实现
```java
public static void selectionSort(int[] arr) {  
    // 遍历数组  
    for (int j = 0; j < arr.length - 1; j++) {  
        // 默认最小值下标 从0 开始  
        int minIndex = j;  
        // 1. (找出最小值下标 minIndex) inIndex后面数组和minIndex进行比较找出最小值下标并赋值给minIndex  
        for (int i = j + 1; i < arr.length; i++) {  
            if (arr[i] < arr[minIndex]) {  
                minIndex = i;  
            }  
        }  
        // 2. 最小值minIndex和j下标的值对换  
        swap(arr, j, minIndex);  
    }  
    print(arr);  
}
```

