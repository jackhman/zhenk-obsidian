  

**-by伯乐老师**

  

  

## 什么微服务架构

  

在martinfowler官网上，martinfowler是这样描述微服务架构的。微服务架构风格是一种将单个应用程序开发为一组小服务的方法，每个服务都在自己的进程中运行，并通过轻量级机制（通常是HTTP资源API）进行服务之间交互。这些服务基于业务能力构建的，可以通过全自动部署机制独立部署。通常情况下我们很少去集中化去管理这些服务，而且这些服务可以用不同的编程语言编写，并使用不同的数据存储技术。

  

## 微服务优缺点

优点：

1.每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。

2.微服务能够被小团队单独开发。

3.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。

4.微服务能使用不同的语言开发。

5.微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。

6.微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。

缺点

1.运维要求较高

2.分布式的复杂性

3.接口调整成本高

  

## Spring Boot Starter 的工作原理是什么？

Spring Boot 在启动的时候会干这几件事情：

① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。

② 根据 spring.factories 配置加载 AutoConfigure 类

③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context

总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。

  

## Spring Boot 的自动配置是如何实现的？

Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：

@Configuration

@ComponentScan

@EnableAutoConfiguration

其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！

  

## Spring 、Spring Boot 和 Spring Cloud 的关系?

  

Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。microservice架构风格是一种将单个应用程序开发为一组小服务的方法，每个服务都在自己的进程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务是围绕业务能力构建的，可以通过全自动部署机制独立部署。对这些服务的集中管理非常有限，这些服务可以用不同的编程语言编写，并使用不同的数据存储技术。

Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。

Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。

Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案

  

## Eureka的服务注册与发现的原理

  

（1）先描述概况和现状

Eureka 是Spring Cloud家族产品最重要组件之一，主要负责负服务注册与发现功能。目前Eureka 1.X仍然继续提供服务，Eureka2已经闭源不再提供服务。

（2）整体描述Eureka工作流程

Eureka包含两个组件：Eureka Server和Eureka Client。在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server，同时也会从Eureka Server下载服务注册信息保存到Eureka Client缓存中。当服务间相互调用其它服务时，在Eureka Client中获取服务信息（如服务地址，端口等）后，实现服务之间的交互。

  

（3）详细描述Eureka几大核心功能

**Register：服务注册**

当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。

**Renew：服务续约**

Eureka Client会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔。

**Fetch Registries：获取注册列表信息**

Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。

**Cancel：服务下线**

Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：DiscoveryManager.getInstance().shutdownComponent()；

  

**Eviction 服务剔除**

在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。

  

（4）自保护模式

  

官网对自保护描述

Eureka servers will enter self preservation mode if they detect that a larger than expected number of registered clients have terminated their connections in an ungraceful way, and are pending eviction at the same time. This is done to ensure catastrophic network events do not wipe out eureka registry data, and having this be propagated downstream to all clients.

如果Eureka服务器检测到超过预期数量的注册客户端以不适当的方式终止了连接，并且正在等待被移除，则Eureka服务器将进入自我保护模式。这样做是为了确保灾难性网络事件不会影响eureka注册表数据以及客户端的调用。

  

  

  

为了更好地理解自我保护，首先了解eureka客户是如何结束注册生命周期的。eureka协议要求客户端在永久离开时执行显式的注销操作。例如，在提供的java客户机中，这是在shutdown（）方法中完成的。任何连续3次心跳更新失败的客户端都将被视为具有不干净的终止，并将被后台逐出进程逐出。当大于15%的当前注册表处于这种稍后状态时，将启用自我保护。

  

在自我保护模式下，eureka服务器将停止逐出所有实例，直到：

（1）它看到的心跳信号更新次数重新高于预期阈值

（2）自我保护被禁用

默认情况下启用自我保护，启用自我保护的默认阈值大于当前注册表大小的15%。

  

如何禁用自我保护

设置属性：eureka.enableSelfPreservation=false.

  

  

**多级缓存**

![](https://cdn.nlark.com/yuque/0/2020/jpeg/1300531/1603704473397-028f9b65-b2bf-4cb6-b049-188043172a03.jpeg?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_45%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

  

**第一级缓存 - readOnlyCacheMap - 外部读取**

为了供客户端获取注册信息时使用，供对外暴露的getRegistry接口读取

ResponseCacheImpl中的`ConcurrentHashMap<Key,Value> readOnlyCacheMap`属性

本质上是 ConcurrentHashMap，无过期时间，保存服务信息的对外输出数据结构,定时从二级缓存拉取注册信息

  

**第二级缓存 - readWriteCacheMap - 中间缓存**

为了降低注册表registry读写锁竞争，降低读取频率,本质上是 guava 的缓存，包含定时失效机制

**过期机制**

- 接收到Eureka Client 发送的 register、renew 和 cancel 请求并更新 registry 注册表之后，使二级缓存失效`invalidate(Key... keys)`；
- Eureka Server 自身的 Evict Task 剔除服务后，删除二级缓存；
- 二级缓存本身设置了 guava 的失效机制，隔一段时间后自己自动失效；

**更新机制**

- Eureka Client 获取全量或者增量的数据时，会先从一级缓存中获取；如果一级缓存中不存在，再从二级缓存中获取；如果二级缓存也不存在，这时候先将registry的数据同步到二级缓存中，再从缓存中获取
- 定时更新一级缓存的时候，会读取二级缓存，如果二级缓存没有数据，也会触发load，拉取registry的注册数据

  

## Ribbon的负载均衡原理

Ribbon是Spring Cloud家族的开源项目，主要功能是提供客户端的软件负载均衡算法，实现服务高可用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法,将请求平摊的分配到多个服务上，从而达到系统的HA。

  

需要注意的是：Ribbon并非直接通过DiscoveryClient从注册中心获取服务的可用提供者，而是通过ServerList<Server>从注册中心获取服务提供者，ServerList与DiscoveryClient不一样，ServerList不是Spring Cloud定义的接口，而是Ribbon定义的接口。

  

**Ribbon自身的负载均衡算法**

RoundRobinRule(轮询算法)

RandomRule(随机算法)

AvailabilityFilteringRule()：会先过滤由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问

WeightedResponseTimeRule()：根据平均响应的时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够会切换到WeightedResponseTimeRule

RetryRule()：先按照RoundRobinRule的策略获取服务，如果获取失败则在制定时间内进行重试，获取可用的服务。

BestAviableRule()：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务

ZoneAvoidanceRule()：默认规则，符合判断server所在区域的性能和server的可用性选择服务器

  

自定义负载均衡算法需要爱继承AbstractLoadBalanceRule类进行自定义算法实现。

  

  

## Hystrix断路器的实现原理

Hystix是Spring Cloud家族产品组件之一，主要用来熔断降级以及资源隔离来保护系统免受级联故障影响。

  

**Hystrix设计目标**：

- 对来自依赖的延迟和故障进行防护和控制——这些依赖通常都是通过网络访问的
- 阻止故障的连锁反应
- 快速失败并迅速恢复
- 回退并优雅降级
- 提供近实时的监控与告警

**Hystrix遵循的设计原则**：

- 防止任何单独的依赖耗尽资源（线程）
- 过载立即切断并快速失败，防止排队
- 尽可能提供回退以保护用户免受故障
- 使用隔离技术（例如隔板，泳道和断路器模式）来限制任何一个依赖的影响
- 通过近实时的指标，监控和告警，确保故障被及时发现
- 通过动态修改配置属性，确保故障及时恢复
- 防止整个依赖客户端执行失败，而不仅仅是网络通信

Hystrix如何实现这些设计目标？

- 使用命令模式将所有对外部服务（或依赖关系）的调用包装在HystrixCommand或HystrixObservableCommand对象中，并将该对象放在单独的线程中执行；
- 每个依赖都维护着一个线程池（或信号量），线程池被耗尽则拒绝请求（而不是让请求排队）。
- 记录请求成功，失败，超时和线程拒绝。
- 服务错误百分比超过了阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求。
- 请求失败，被拒绝，超时或熔断时执行降级逻辑。
- 近实时地监控指标和配置的修改。

  

  

**Hystrix工作流程**

  

![](https://cdn.nlark.com/yuque/0/2020/png/1300531/1603702764991-39afd0fc-6f7d-47cc-bcd4-d85fb76435d2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_50%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

- 1、创建HystrixCommand 或者 HystrixObservableCommand 对象
- 2、执行命令execute()、queue()、observe()、toObservable()
- 3、如果请求结果缓存这个特性被启用，并且缓存命中，则缓存的回应会立即通过一个Observable对象的形式返回
- 4、检查熔断器状态，确定请求线路是否是开路，如果请求线路是开路，Hystrix将不会执行这个命令，而是直接执行getFallback
- 5、如果和当前需要执行的命令相关联的线程池和请求队列，Hystrix将不会执行这个命令，而是直接执行getFallback
- 6、执行HystrixCommand.run()或HystrixObservableCommand.construct()，如果这两个方法执行超时或者执行失败，则执行getFallback()
- 7、Hystrix 会将请求成功，失败，被拒绝或超时信息报告给熔断器，熔断器维护一些用于统计数据用的计数器。

这些计数器产生的统计数据使得熔断器在特定的时刻，能短路某个依赖服务的后续请求，直到恢复期结束，若恢复期结束根据统计数据熔断器判定线路仍然未恢复健康，熔断器会再次关闭线路。

  

**Hystrix****断路器****工作原理：**

  

![](https://cdn.nlark.com/yuque/0/2020/png/1300531/1603701896021-32b11e9e-c729-4624-8a20-09a4bbe3727c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

  

断路器开启或者关闭的条件：

　　　　 1、 当满足一定的阀值时候 （默认 10 秒内 超过 20 个请求 次数 ）

　　　　 2、 当失败率达到一定的时候（ 默认 10 秒内超过 秒内超过 50%的请求失败 ）

　　　　 3、 到达以上阀值 ，断路器将会开启

　　　　 4、 当开启的时候 ，所有请求 都不会进行转发

　　　　 5、 一段时间之后（ 默认是 5秒），这个时候断路器是半开状态， 会让其中一请求进行转发。如果成功断路器会关闭，若失败继续开启。重复 4和 5。

  

**Hystrix特性**

- 请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.

  

- 服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。
- 依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池.比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。

  

- 请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。
- 请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。

  

  

**Hystix解决了什么问题？**

复杂分布式体系结构中的应用程序通常有几十个依赖项，每个依赖项都不可避免地在某个时刻失败。如果主机应用程序没有与这些外部故障隔离开来，那么出现风险就有可能让整个集群服务崩溃。

例如，对于一个依赖于30个服务的应用程序，其中每个服务的正常运行时间为99.99%，您可以期望：

99.9930=99.7%正常运行时间

10亿个请求中的0.3%=3000000个失败

即使所有依赖项都有很好的正常运行时间，每月停机2小时以上。

现实通常比这个情况更糟。

即使所有的依赖性都表现良好，如果您不设计整个系统的弹性，那么即使是0.01%的停机时间对几十个服务中的每一个服务的总影响也相当于一个月可能有几个小时的停机时间

  

**熔断器有以下几个主要配置**

  

![](https://cdn.nlark.com/yuque/0/2020/png/1300531/1603703085122-b1812988-a9f4-43ac-b14e-97cd9deb4cc7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_6bKB54-t5a2m6Zmi5Ye65ZOB%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

  

  

  

[https://design.codelytics.io/hystrix/how-it-works](https://design.codelytics.io/hystrix/how-it-works)

  

## Nacos的服务注册发现机制的原理

Nacos是Spring Cloud Alibaba生态重要组件之一，它能够提供服务注册发现以及配置管理功能。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理：

[Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/)

[gRPC](https://grpc.io/docs/guides/concepts.html#service-definition) & [Dubbo RPC Service](https://dubbo.incubator.apache.org/)

[Spring Cloud RESTful Service](https://spring.io/understanding/REST)

  

解决读写冲突

  

线程池 + 阻塞队列+异步处理

  

  

Ｎａｃｏｓ: 　ＡＰ　＋ＣＰ　

  

Eureka：　ＡＰ　

  

  

Zookeeper服务注册发现原理

Eureka，Nacos和ZooKeeper注册中心区别

Zuul网关实现的原理

Feign的工作流程

SpringCloud Config可以实现实时刷新吗?

Sentinel核心功能工作原理